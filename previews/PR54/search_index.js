var documenterSearchIndex = {"docs":
[{"location":"index.html#Rimu.jl-Package-Guide","page":"Guide","title":"Rimu.jl Package Guide","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"Random Integrators for many-body quantum systems","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"The grand aim is to develop a toolbox for many-body quantum systems that can be represented by a Hamiltonian in second quantisation language. Currently there are tools to find the ground state with FCIQMC or with a Lanczos algorithm (using KrylovKit for small Hilbert spaces). We will add tools to solve the time-dependent Schrödinger equation and Master equations for open system time evolution.","category":"page"},{"location":"index.html#Contents","page":"Guide","title":"Contents","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"Pages = [\"index.md\",\"hamiltonians.md\",\"consistentrng.md\",\"documentation.md\",\n            \"testing.md\",\"API.md\",\"BHM-example.md\"]\nDepth = 4","category":"page"},{"location":"index.html#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"index.html#Install-Rimu-for-running-jobs-only","page":"Guide","title":"Install Rimu for running jobs only","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"Rimu can be installed with the package manager directly from the bitbucket repository. Either hit the ] key at the Julia REPL to get into Pkg mode and type","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"pkg> add https://github.com/joachimbrand/Rimu.jl#master","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"where master can be exchanged with the name of the desired git branch. Alternatively, use","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"julia> using Pkg; Pkg.add(PackageSpec(url=\"https://github.com/joachimbrand/Rimu.jl\", rev=\"master\"))","category":"page"},{"location":"index.html#Install-Rimu-for-development","page":"Guide","title":"Install Rimu for development","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"In order to be able to edit the source code, push changes, change and make new git branches, etc., clone the git repository with git clone to a convenient location, e.g. ~/mygitpackagefolder/. Then hit the ] key at the Julia REPL to get into Pkg mode and type","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"pkg> develop ~/mygitpackagefolder/rimu.jl","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"where the file path has to be adjusted to the location of the cloned git repository.","category":"page"},{"location":"index.html#Usage","page":"Guide","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"The package is now installed and can be imported with","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"julia> using Rimu","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"When planning to edit the code of the package it is advisable to use the Revise package by issuing","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"julia> using Revise","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"before using Rimu. This will track any changes made to the source code of Rimu and the changed package will be available after saving the source code (hopefully, and most of the time, without restarting the Julia REPL).","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Rimu offers a number of tools for representing Hamiltonians (see Hamiltonians) and state vectors / wave functions (see DictVectors) as well as algorithms to find the ground state, e.g. lomc!.","category":"page"},{"location":"index.html#Scripts","page":"Guide","title":"Scripts","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"Rimu is written as a Julia package to be imported with using Rimu as described above. It supplies useful functions and types. Performing actual calculations and analysing the results is done with scripts. The folder scripts/ contains a collections of scripts that are either examples for use of the Rimu package or useful scripts for data analysis. In particular:","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"scripts/BHM-example.jl is an example script that runs fciqmc on the 1D Bose-Hubbard model. A data frame with results is written to the file fciqmcdata.feather.\nscripts/BHM-example-mpi.jl is an example script that runs the same fciqmc calculation as above with MPI enabled.\nscripts/read_file_and_plot.jl reads the feather file (from the working directory) and displays basic plots and blocking analysis of the shift.\nplotting.jl is a collection of (currently very primitive) plotting function. On purpose these are not part of the Rimu package in order to avoid a dependency on a plotting package.","category":"page"},{"location":"index.html#MPI","page":"Guide","title":"MPI","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"The Rimu package can run in parallel on different processes or node and distribute work by making use of MPI, or \"message passing interface\". For example, running","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"> julia scripts/BHM-example.jl","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"will run on one processor with the main lomc!() computation (i.e. after package loading and compilation) completing in 2.69 seconds.","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Running","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"> mpirun -np 4 julia scripts/BHM-example-mpi.jl","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"on the same hardware makes use of 4 cores and the main part completes in 1.04 seconds, a speedup factor of 2.6. This seems reasonable, given that extra work needs to be done for communicating between different processes.","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Initialising and finalising MPI communication has to be handled at the script level. Enabling MPI communication for use in lomc!() is done by wrapping the primary data structures as MPIData. A number of different strategies for data communication are implemented and most easily accessed with the functions:","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"mpi_default\nmpi_one_sided\nmpi_no_exchange","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"See examples in the Scripts folder.","category":"page"},{"location":"index.html#References","page":"Guide","title":"References","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"The code implements the FCIQMC algorithm described in","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"\"Fermion Monte Carlo without fixed nodes: A game of life, death, and annihilation in Slater determinant space\", G. H. Booth, A. J. W. Thom, A. Alavi, J. Chem. Phys. 131, 054106 (2009).","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Scientific papers using the Rimu code:","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"\"Improved walker population control for full configuration interaction quantum Monte Carlo\", M. Yang, E. Pahl, J. Brand, J. Chem. Phys. 153, 170143 (2020); DOI: 10.1063/5.0023088; arXiv:2008.01927.","category":"page"},{"location":"hamiltonians.html#Developer-Documentation","page":"Hamiltonians","title":"Developer Documentation","text":"","category":"section"},{"location":"hamiltonians.html#Module-Hamiltionians.jl","page":"Hamiltonians","title":"Module Hamiltionians.jl","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"This module contains definitions of Hamiltonians, in particular specific physical models of interest. These are organised by means of an interface around the abstract type AbstractHamiltonian, in the spirit of the AbstractArray interface as discussed in the Julia Documentation.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"Hamiltonians","category":"page"},{"location":"hamiltonians.html#Rimu.Hamiltonians","page":"Hamiltonians","title":"Rimu.Hamiltonians","text":"module Hamiltonians\n\nThis module defines Hamiltonian types, interfaces, and functions for working with Hamiltonians.\n\n\n\n\n\n","category":"module"},{"location":"hamiltonians.html#Relation-to-other-parts-of-the-Rimu-code","page":"Hamiltonians","title":"Relation to other parts of the Rimu code","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"In order to define a specific model Hamiltonian with relevant parameters for the model, instantiate the model like this in the input file:","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"ham = BoseHubbardReal1D(n=6, m=6, u=1.0, t=1.0, AT = BSAdd64)","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"In the rest of the Rimu code, access to properties and matrix elements of the model are then provided by the following methods:","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"ham[address1, address2]:  indexing of matrix elements (slow - use with caution)\nham(dv::AbstractDVec) or mul!(dv1, ham, dv2): use as linear operator\ndiagME(ham, add): diagonal matrix element\nnumOfHops(ham, add): number of off-diagonals\nhop(ham, add, chosen): access off-diagonal matrix element\nHops(ham, add): iterator over off-diagonal matrix elements\ngenerateRandHop(hops::Hops): choose random off-diagonal\nbit_String_Length(ham): number of bits in the configuration\nham(:dim) and ham(:fdim): dimension of linear space. See  hasIntDimension(ham), dimensionLO(ham), fDimensionLO(ham)\nnearUniform(ham): configuration with particles spread across modes","category":"page"},{"location":"hamiltonians.html#Model-Hamiltonians","page":"Hamiltonians","title":"Model Hamiltonians","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"Here is a list of fully implemented model Hamiltonians. So far there are two variants implemented of the one-dimentional Bose-Hubbard model real space as well as a momentum-space Hubbard chain.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"BoseHubbardReal1D\nExtendedBHReal1D\nBoseHubbardMom1D","category":"page"},{"location":"hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D","page":"Hamiltonians","title":"Rimu.Hamiltonians.BoseHubbardReal1D","text":"ham = BoseHubbardReal1D(;[n=6, m=6, u=1.0, t=1.0, AT = BSAdd64])\n\nImplements a one-dimensional Bose Hubbard chain in real space.\n\nhatH = -t sum_langle ijrangle a_i^ a_j + fracu2sum_i n_i (n_i-1)\n\nwarning: Warning\nThis Hamiltonian is deprecated. Please use HubbardReal1D instead.\n\nArguments\n\nn::Int: the number of bosons\nm::Int: the number of lattice sites\nu::Float64: the interaction parameter\nt::Float64: the hopping strength\nAT::Type: the address type\n\nFunctor use:\n\nw = ham(v)\nham(w, v)\n\nCompute the matrix - vector product w = ham * v. The two-argument version is mutating for w.\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Rimu.Hamiltonians.ExtendedBHReal1D","page":"Hamiltonians","title":"Rimu.Hamiltonians.ExtendedBHReal1D","text":"ham = ExtendedBHReal1D(n=6, m=6, u=1.0, v=1.0, t=1.0, AT=BSAdd64)\n\nImplements the extended Bose Hubbard model on a one-dimensional chain in real space.\n\nhatH = -t sum_langle ijrangle a_i^ a_j + fracu2sum_i n_i (n_i-1) + v sum_langle ijrangle n_i n_j\n\nArguments\n\nn::Int: number of bosons\nm::Int: number of lattice sites\nu::Float64: on-site interaction parameter\nv::Float64: the next-neighbor interaction\nt::Float64: the hopping strength\nAT::Type: address type for identifying configuration\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D","page":"Hamiltonians","title":"Rimu.Hamiltonians.BoseHubbardMom1D","text":"ham = BoseHubbardMom1D(;[n=6, m=6, u=1.0, t=1.0], add = add)\nham = BoseHubbardMom1D(add; u=1.0, t=1.0)\n\nImplements a one-dimensional Bose Hubbard chain in momentum space.\n\nhatH = sum_k ϵ_k n_k + fracuMsum_kpqr a^_r a^_q a_p a_k δ_r+qp+k\nϵ_k = -2t cos(k)\n\nwarning: Warning\nThis Hamiltonian is deprecated. Please use HubbardMom1D instead.\n\nArguments\n\nn::Int: the number of bosons\nm::Int: the number of lattice sites\nu::Float64: the interaction parameter\nt::Float64: the hopping strength\nAT::Type: the address type\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Hamiltonians-interface","page":"Hamiltonians","title":"Hamiltonians interface","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"Behind the implementation of a particular model is a more abstract interface for defining hamiltonians. If you want to define a new model you should make use of this interface. The most general form of a model Hamiltonian should subtype to AbstractHamiltonian and implement the relevant methods.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"AbstractHamiltonian\nHops\ngenerateRandHop","category":"page"},{"location":"hamiltonians.html#Rimu.Hamiltonians.AbstractHamiltonian","page":"Hamiltonians","title":"Rimu.Hamiltonians.AbstractHamiltonian","text":"AbstractHamiltonian{T}\n\nSupertype that provides an interface for linear operators over a linear space with scalar type T that are suitable for FCIQMC. Indexing is done with addresses (typically not integers) from an address space that may be large (and will not need to be completely generated).\n\nAbstractHamiltonian instances operate on vectors of type AbstractDVec from the module DictVectors and work well with addresses of type AbstractFockAddress from the module BitStringAddresses. The type works well with the external package KrylovKit.jl.\n\nMethods\n\nProvides:\n\noffdiagonals: iterator over reachable off-diagonal matrix elements\nrandom_offdiagonal: function to generate random off-diagonal matrix element\ndimension: get the dimension of the address space.\nH[address1, address2]: indexing with getindex() - mostly for testing purposes\n*(H, v): deterministic matrix-vector multiply.\nH(v): equivalent to H * v.\nmul!(w, H, v): mutating matrix-vector multiply.\ndot(x, H, v): compute x⋅(H*v) minimizing allocations.\n\nMethods that need to be implemented:\n\nnum_offdiagonals(::AbstractHamiltonian, address)\nget_offdiagonal(::AbstractHamiltonian, address, chosen::Integer)\ndiagonal_element(::AbstractHamiltonian, address)\nstarting_address(::AbstractHamiltonian)\n\nOptional methods to implement:\n\nHamiltonians.LOStructure(::Type{typeof(lo)})\ndimension(::Type{T}, ::AbstractHamiltonian)\noffdiagonals(::AbstractHamiltonian, ::AbstractFockAddress)\nmomentum(::AbstractHamiltonian)\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Core-functions","page":"Hamiltonians","title":"Core functions","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"The following functions are part of the core functionality of a Hamiltonian and need to be implemented efficiently and specifically for each model.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"numOfHops\nhop\ndiagME","category":"page"},{"location":"hamiltonians.html#BosonicHamiltonian","page":"Hamiltonians","title":"BosonicHamiltonian","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"For a many-body system consisting of spinless bosons, we already know more about the structure of the problem. BosonicHamiltonian is a pre-defined subtype of AbstractHamiltonian.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"BosonicHamiltonian\nhasIntDimension\ndimensionLO\nfDimensionLO\nbit_String_Length\nnearUniform","category":"page"},{"location":"hamiltonians.html#Rimu.BitStringAddresses.nearUniform","page":"Hamiltonians","title":"Rimu.BitStringAddresses.nearUniform","text":"nearUniform(BoseFS{N,M})\nnearUniform(BoseFS{N,M,S}) -> bfs::BoseFS{N,M,S}\n\nCreate bosonic Fock state with near uniform occupation number of M modes with a total of N particles. Specifying the bit address type S is optional.\n\nExamples\n\njulia> nearUniform(BoseFS{7,5,BitString{14}})\nBoseFS((2,2,1,1,1))\n\njulia> nearUniform(BoseFS{7,5})\nBoseFS((2,2,1,1,1))\n\n\n\n\n\n","category":"function"},{"location":"consistentrng.html#Random-Numbers","page":"Random Numbers","title":"Random Numbers","text":"","category":"section"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"Generating good quality random numbers is crucial for any Monte Carlo code. In addition to generating pseudo random numbers with good statistics and in minimal CPU time, we also have the requirement that computations should be reproducible and the random number sequences independent on each worker when the code runs in parallel mode.","category":"page"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"We define the random number generator in the module ConsistentRNG.jl, which is loaded onto each process. Furthermore, independent seeds are used to seed the RNGs on each worker (from goQMC.jl). These seeds are generated using the Random.RandomDevice random number generator, which draws entropy from the operating system / hardware. The seeds are saved to file with a filename that includes the number of processes used. If a suitable file is found, then seeds are read in from the file. This behaviour can be controlled by the flag reuseRandomSeeds in the input file.","category":"page"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"For the random number generator we are currently using 'Xoroshiro128Plus' from 'RandomNumbers.jl'. For benchmarks and statistical test results see the Documentation of RandomNumbers.jl.","category":"page"},{"location":"consistentrng.html#Module-ConsistentRNG.jl","page":"Random Numbers","title":"Module ConsistentRNG.jl","text":"","category":"section"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"Modules = [Rimu.ConsistentRNG]","category":"page"},{"location":"consistentrng.html#Rimu.ConsistentRNG","page":"Random Numbers","title":"Rimu.ConsistentRNG","text":"module ConsistentRNG\n\nProvides a an array random number generators with one for each thread.\n\nExports cRand() and seedCRNG!(). These are thread consistent.\n\n\n\n\n\n","category":"module"},{"location":"consistentrng.html#Rimu.ConsistentRNG.CRNGs","page":"Random Numbers","title":"Rimu.ConsistentRNG.CRNGs","text":"CRNGs[]\n\nDefines an array of random number generators suitable for threaded code. For MPI or distributed runs it should be seeded separately on each process with seedCRNG!. Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post. In order to change the random number generator, edit 'ConsistentRNG.jl'.\n\nrng = CRNGs[][Threads.threadid()]\nrand(rng)\n\n\n\n\n\n","category":"constant"},{"location":"consistentrng.html#Rimu.ConsistentRNG.CRNG","page":"Random Numbers","title":"Rimu.ConsistentRNG.CRNG","text":"Baseline random number generator used throughout. Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post. In order to change the random number generator, edit 'ConsistentRNG.jl'.\n\n\n\n\n\n","category":"type"},{"location":"consistentrng.html#Rimu.ConsistentRNG.cRand-Tuple","page":"Random Numbers","title":"Rimu.ConsistentRNG.cRand","text":"r = cRand(args...)\n\nSimilar to 'rand(args)' but uses consistent random number generator 'CRNGs[]'. 'cRand()' generates a single uniformly distributed random number in the interval [0,1). Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.cRandn-Tuple","page":"Random Numbers","title":"Rimu.ConsistentRNG.cRandn","text":"r = cRandn(args...)\n\nSimilar to 'randn(args)' but uses consistent random number generators 'CRNGs[]'. 'cRandn()' generates a single normally distributed random number. Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.check_crng_independence-Tuple{Any}","page":"Random Numbers","title":"Rimu.ConsistentRNG.check_crng_independence","text":"ConsistentRNG.check_crng_independence(v)\n\nPrimitve test to check the random number generators. It throws an error if some of the threaded random number generators are equal. Returns the number of threaded RNGs.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.newChildRNG","page":"Random Numbers","title":"Rimu.ConsistentRNG.newChildRNG","text":"newChildRNG(parent_rng = trng())\n\nRandom number generator that is seeded deterministically from the thread-consistent global rng trng(). By scrambling with hash(), a statistically independent pseudo-random sequence from the parent rng is accessed.\n\n\n\n\n\n","category":"function"},{"location":"consistentrng.html#Rimu.ConsistentRNG.seedCRNG!-Tuple{Vector{T} where T}","page":"Random Numbers","title":"Rimu.ConsistentRNG.seedCRNG!","text":"seedCRNG!([seed])\n\nSeed the threaded consistent random number generators CRNGs[]. If a single number is given, this will be used to seed a random sequence, which is hashed and then used to generate seeds for each rng in the vector CRNGs. When no argument is given, each rng is seeded randomly.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.sync_cRandn-Tuple{Any}","page":"Random Numbers","title":"Rimu.ConsistentRNG.sync_cRandn","text":"sync_cRandn(v)\n\nGenerate one random number with cRandn() in a synchronous way. Defaults to cRandn().\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.trng-Tuple{}","page":"Random Numbers","title":"Rimu.ConsistentRNG.trng","text":"trng()\n\nThread local random number generator.\n\nrand(trng())\nrand(trng(),UInt)\n\n\n\n\n\n","category":"method"},{"location":"testing.html#Code-testing","page":"Code testing","title":"Code testing","text":"","category":"section"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"The script runtest.jl in the test/ folder contains tests of the code. To run the test simply run the script from the Julia REPL or run","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"Rimu$ julia test/runtest.jl","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"from the command line.","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"More tests should be added over time to test core functionality of the code. To add new tests, directly edit the file runtest.jl.","category":"page"},{"location":"testing.html#Automated-testing-with-Pipelines","page":"Code testing","title":"Automated testing with Pipelines","text":"","category":"section"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"Bitbucket Pipelines are set up to run the test script automatically on the Bitbucket cloud server every time a new commit to the master branch is pushed to the server. The setup for this to happen is configured in the file bitbucket-pipelines.yml in the Rimu/ folder.","category":"page"},{"location":"testing.html#Modifying-the-Project.toml-file","page":"Code testing","title":"Modifying the Project.toml file","text":"","category":"section"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"In order for the testing code to be able to run on the cloud server, external packages that are accessed in the code with using or import need to be installed first. This is done in the script bitbucket-pipelines.yml via the package manager, based on the information contained in the file test/Project.toml. More packages can be added to this file using the package manager in the following way: Say we want to install the package DelimitedFiles. At the Julia REPL, type the following:","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"julia> cd(\"test\")\njulia> ]\n(v1.0) pkg> activate .\n(test) pkg> add DelimitedFiles","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"This will a new line to the file Project.toml with the name of the package and the corresponding uuid. When Pipelines now runs the commands in yml script, it will install the package DelimitedFiles before running the runtest.jl script.","category":"page"},{"location":"BHM-example.html#Example:-1D-Bose-Hubbard-Model","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"","category":"section"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"This is an example calculation finding the ground state of a 1D Bose-Hubbard chain with 6 particles in 6 lattice site. The Julia run-able script is in scripts/BHM-example.jl.","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Firstly, we load all needed modules. Rimu for FCIQMC calculation (obviously); Feather for saving output data in a DataFrame using DataFrames:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"using Rimu\nusing Feather\nusing DataFrames","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now we define the physical problem: Setting the number of lattice sites m = 6; and the number of particles n = 6:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"m = n = 6","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Generating a configuration that particles are evenly distributed:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"aIni = nearUniform(BoseFS{n,m})","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"The Hamiltonian is defined based on the configuration aIni, with additional onsite interaction strength u = 6.0 and the hopping strength t = 1.0:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Ĥ = BoseHubbardReal1D(aIni; u = 6.0, t = 1.0)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now let's setup the Monte Carlo settings. The number of walkers to use in this Monte Carlo run:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"targetwalkers = 1_000","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"The number of time steps before doing statistics, i.e. letting the walkers to sample Hilbert and to equilibrate:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"steps_equilibrate = 1_000","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"And the number of time steps used for getting statistics, e.g. time-average of shift, projected energy, walker numbers, etc.:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"steps_measure = 1_000","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Set the size of a time step","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"dτ = 0.001","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"and we report QMC data every k-th step, setting k = 1 means we record QMC data every step:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"k = 1","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now we prepare initial state and allocate memory. The initial address is defined above as aIni = nearUniform(Ĥ). Define the initial number of walkers per rank:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"nIni = 1","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Putting the nIni number of walkers into the initial address aIni, and set the DVec size to be targetwalkers*10:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"svec = DVec(Dict(aIni => nIni), targetwalkers*10)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Let's plant a seed for the random number generator to get consistent result:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Rimu.ConsistentRNG.seedCRNG!(17)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now let's setup all the FCIQMC strategies.","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Passing dτ and total number of time steps into params:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"params = RunTillLastStep(dτ = dτ, laststep = steps_equilibrate + steps_measure)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Strategy for updating the shift:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"s_strat = DoubleLogUpdate(targetwalkers = targetwalkers, ζ = 0.08)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Strategy for reporting info and setting projectors:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"r_strat = ReportDFAndInfo(k = k, i = 100, projector = UniformProjector())","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Strategy for updating dτ:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"t_strat = ConstantTimeStep()","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Print out info about what we are doing:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"println(\"Finding ground state for:\")\nprintln(Ĥ)\nprintln(\"Strategies for run:\")\nprintln(params, s_strat)\nprintln(t_strat)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Finally, we can start the main FCIQMC loop:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"r_strat = ReportDFAndInfo(k = k, projector = UniformProjector(), writeinfo = false) # hide\ndf = lomc!(Ĥ,svec;\n            params = params,\n            laststep = steps_equilibrate + steps_measure,\n            s_strat = s_strat,\n            r_strat = r_strat,\n            τ_strat = t_strat)\nprintln(\"Writing data to disk...\")","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Saving output data stored in df.df into a .feather file which can be read in later:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Feather.write(\"fciqmcdata.feather\", df.df)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now do some quick statistics:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"(qmcShift,qmcShiftErr,qmcEnergy,qmcEnergyErr) = autoblock(df.df,start=steps_equilibrate)\nprintln(\"Energy from $steps_measure steps with $targetwalkers walkers:\nShift: $qmcShift ± $qmcShiftErr\nE_proj:$qmcEnergy ± $qmcEnergyErr\")","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Finished !","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"println(\"Finished!\")","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"documentation.html#Documentation-generation","page":"Documentation generation","title":"Documentation generation","text":"","category":"section"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"We are using Documenter.jl to generate the documentation web site based on markdown files stored in docs/src. Please help keeping the documentation up-to-date by editing the markdown files! For instructions on how to write appropriate documentation please refer to the relevant chapter in the Julia documentation and the Documenter.jl documentation.","category":"page"},{"location":"documentation.html#Generating-the-documentation-web-site","page":"Documentation generation","title":"Generating the documentation web site","text":"","category":"section"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"The documentation pages can be generated by running the build script by typing","category":"page"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"Rimu$ julia docs/build.jl","category":"page"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"on the shell prompt from the Rimu/ folder. A complete image of the static documentation web site will be generated in the folder docs/build/. It can be viewed locally by pointing a web browser to file docs/build/index.html, or by deploying it to the Bitbucket pages web server.","category":"page"},{"location":"documentation.html#Automatic-documentation-generation-and-deployment","page":"Documentation generation","title":"Automatic documentation generation and deployment","text":"","category":"section"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"Our documentation is hosted on a Bitbucket pages web site. The documentation web site can be built and deployed automatically with BitBucket pipelines. This needs to be set up with an appropriate script in the file bitbucket-pipelines.yml in the project folder, where triggers for this to happen can be defined. In the current set up, a new documentation web site is generated and deployed whenever someone pushes to the master branch on the BitBucket server. The updated documentation can then be accessed at https://joachimbrand.bitbucket.io/Rimu.jl/dev/.","category":"page"},{"location":"API.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"API.html#Rimu","page":"API","title":"Rimu","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [Rimu]","category":"page"},{"location":"API.html#Rimu.Rimu","page":"API","title":"Rimu.Rimu","text":"Rimu\n\nRandom Integrator for Many-Body Quantum Systems\n\n\n\n\n\n","category":"module"},{"location":"API.html#Rimu.ComplexNoiseCancellation","page":"API","title":"Rimu.ComplexNoiseCancellation","text":"ComplexNoiseCancellation(κ = 1.0) <: ProjectStrategy\n\nUse complex noise cancellation strategy with imaginary noise injected at level κ. See norm_project.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ConstantTimeStep","page":"API","title":"Rimu.ConstantTimeStep","text":"Keep dτ constant.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedDoubleLogUpdate","page":"API","title":"Rimu.DelayedDoubleLogUpdate","text":"DelayedDoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, A=10) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ and delay of A steps. See DoubleLogUpdate.\n\nS^n+A = S^n -fracζA dτlnleft(fracΨ_1^n+AΨ_1^nright)-fracξA dτlnleft(fracΨ_1^n+AΨ_1^texttargetright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedDoubleLogUpdateAfterTW","page":"API","title":"Rimu.DelayedDoubleLogUpdateAfterTW","text":"DelayedDoubleLogUpdateAfterTW(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, A=10) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ and delay of A steps after the number of target walkers is reached. See DoubleLogUpdate.\n\nS^n+A = S^n -fracζA dτlnleft(fracΨ_1^n+AΨ_1^nright)-fracξA dτlnleft(fracΨ_1^n+AΨ_1^texttargetright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedLogUpdate","page":"API","title":"Rimu.DelayedLogUpdate","text":"DelayedLogUpdate(ζ = 0.08, a = 10) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and delay of a steps.\n\nS^n+a = S^n -fracζa dτlnleft(fracΨ_1^n+aΨ_1^nright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedLogUpdateAfterTargetWalkers","page":"API","title":"Rimu.DelayedLogUpdateAfterTargetWalkers","text":"DelayedLogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, a = 10) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ and delay of a steps. See DelayedLogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DeltaMemory","page":"API","title":"Rimu.DeltaMemory","text":"DeltaMemory(Δ::Int) <: MemoryStrategy\n\nBefore updating the shift, memory noise with a memory length of Δ is applied, where Δ = 1 means no memory noise.\n\nr̃ = (pnorm - tnorm)/(dτ*pnorm) + shift\nr = r̃ - <r̃>\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DeltaMemory2","page":"API","title":"Rimu.DeltaMemory2","text":"DeltaMemory2(Δ::Int) <: MemoryStrategy\n\nBefore updating the shift, memory noise with a memory length of Δ is applied, where Δ = 1 means no memory noise.\n\nr̃ = pnorm - tnorm + shift*dτ*pnorm\nr = (r̃ - <r̃>)/(dτ*pnorm)\n\nThe long-term average of r is not guaranteed to be zero.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DeltaMemory3","page":"API","title":"Rimu.DeltaMemory3","text":"DeltaMemory3(Δ::Int, level::Float64) <: MemoryStrategy\n\nBefore updating the shift, apply multiplicative memory noise with a memory length of Δ at level level, where Δ = 1 means no memory noise.\n\nr̃ = (pnorm - tnorm)/pnorm + dτ*shift\nr = r̃ - <r̃>\nw .*= 1 + level*r\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DontUpdate","page":"API","title":"Rimu.DontUpdate","text":"DontUpdate() <: ShiftStrategy Don't update the shift.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogProjected","page":"API","title":"Rimu.DoubleLogProjected","text":"DoubleLogProjected(; target, projector, ζ = 0.08, ξ = ζ^2/4) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ after projecting onto projector.\n\nS^n+1 = S^n -fracζdτlnleft(fracPΨ^(n+1)PΨ^(n)right)-fracξdτlnleft(fracPΨ^(n+1)texttargetright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogUpdate","page":"API","title":"Rimu.DoubleLogUpdate","text":"DoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ.\n\nS^n+1 = S^n -fracζdτlnleft(fracΨ_1^n+1Ψ_1^nright)-fracξdτlnleft(fracΨ_1^n+1Ψ_1^texttargetright)\n\nWhen ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogUpdateAfterTargetWalkers","page":"API","title":"Rimu.DoubleLogUpdateAfterTargetWalkers","text":"LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, ξ = 0.0016) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ and ξ. See DoubleLogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogUpdateAfterTargetWalkersSwitch","page":"API","title":"Rimu.DoubleLogUpdateAfterTargetWalkersSwitch","text":"LogUpdateAfterTargetWalkersSwitch(targetwalkers, ζ = 0.08, ξ = 0.0016) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ and ξ. After a steps the strategy switches to LogUpdate. See DoubleLogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.EveryKthStep","page":"API","title":"Rimu.EveryKthStep","text":"EveryKthStep(;k = 10, projector = nothing, hproj = :auto)\n\nReport every kth step. Include projection onto projector. See ReportingStrategy for details.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.EveryTimeStep","page":"API","title":"Rimu.EveryTimeStep","text":"EveryTimeStep(;projector = nothing, hproj = :auto)\n\nReport every time step. Include projection onto projector. See ReportingStrategy for details.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.FciqmcRunStrategy","page":"API","title":"Rimu.FciqmcRunStrategy","text":" FciqmcRunStrategy{T}\n\nAbstract type representing the strategy for running and terminating fciqmc!(). The type parameter T is relevant for reporting the shift and the norm.\n\nImplemented strategies:\n\nRunTillLastStep\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.HistoryLogUpdate","page":"API","title":"Rimu.HistoryLogUpdate","text":"HistoryLogUpdate(df::DataFrame; d = 100, k=1, ζ= 0.08)\n\nStrategy for updating the shift according to log formula but with walker numbers accumulated from k samples of the history with delay d. A recent history has to be passed with the data frame df for initialisation.\n\nN_w^n = sum_i=0^k-1 Ψ_1^n-i \nS^n+a = S^n -fracζa dτlnleft(fracN_w^n+1N_w^nright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.LogUpdate","page":"API","title":"Rimu.LogUpdate","text":"LogUpdate(ζ = 0.08) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ.\n\nS^n+1 = S^n -fracζdτlnleft(fracΨ_1^n+1Ψ_1^nright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.LogUpdateAfterTargetWalkers","page":"API","title":"Rimu.LogUpdateAfterTargetWalkers","text":"LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ. See LogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.MemoryStrategy","page":"API","title":"Rimu.MemoryStrategy","text":"Abstract type for defining the strategy for injectimg memory noise. Implemented strategies:\n\nNoMemory\nDeltaMemory\nShiftMemory\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.NoMemory","page":"API","title":"Rimu.NoMemory","text":"NoMemory <: MemoryStrategy\n\nDefault strategy for MemoryStrategy indicating that no memory noise will be used.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.NoProjection","page":"API","title":"Rimu.NoProjection","text":"Do not project the walker amplitudes. See norm_project.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.NoProjectionTwoNorm","page":"API","title":"Rimu.NoProjectionTwoNorm","text":"Do not project the walker amplitudes. Use two-norm to calculate walker numbers. This affects reported \"norm\" but also the shift update procedures. See norm_project.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ProjectStrategy","page":"API","title":"Rimu.ProjectStrategy","text":"Abstract type for defining the strategy of projection for fciqmc with floating point walker number with norm_project. Implemented strategies:\n\nNoProjection\nNoProjectionTwoNorm\nThresholdProject\nScaledThresholdProject\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ProjectedMemory","page":"API","title":"Rimu.ProjectedMemory","text":"ProjectedMemory(Δ::Int, projector, pp::Number) <: MemoryStrategy\nProjectedMemory(Δ::Int, projector, v::AbstractDVec)\n\nBefore updating the shift, apply memory noise to minimize the fluctuations of the overlap of the coefficient vector with projector. Averaging over Δ time steps is applied, where Δ = 1 means no memory noise is applied. Use pp to initialise the value of the projection or pass v in order to initialise the projection with pp = projector.v.\n\nr̃ = (projector⋅v - projector⋅w)/projector⋅v + dτ*shift\nr = r̃ - <r̃>\n\nwhere v is the coefficient vector before and w after applying a regular FCIQMC step.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.PurgeNegatives","page":"API","title":"Rimu.PurgeNegatives","text":"PurgeNegatives <: MemoryStrategy\n\nPurge all negative sign walkers.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ReportDFAndInfo","page":"API","title":"Rimu.ReportDFAndInfo","text":"ReportDFAndInfo(; k=10, i=100, io=stdout, writeinfo=true, projector = nothing, hproj = :auto)\n\nReport every kth step in DataFrame and write info message to io every ith step (unless writeinfo == false). The flag writeinfo is useful for controlling info messages in MPI codes. Include projection onto projector. See ReportingStrategy for details.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ReportingStrategy","page":"API","title":"Rimu.ReportingStrategy","text":"ReportingStrategy\n\nAbstract type for strategies for reporting data in a DataFrame with report!(). It also affects the calculation and reporting of projected quantities in the DataFrame.\n\nImplemented strategies:\n\nEveryTimeStep\nEveryKthStep\nReportDFAndInfo\n\nEvery strategy accepts the keyword arguments projector and hproj according to which a projection of the instantaneous coefficient vector projector⋅v and hproj⋅v are reported to the DataFrame  in the fields df.vproj and df.hproj, respectively. Possible values for projector are\n\nnothing - no projections are computed (default)\ndv::AbstractDVec - compute projection onto coefficient vector dv (set up with copytight to conserve memory)\nUniformProjector() - projection onto vector of all ones\nNormProjector() - compute 1-norm instead of projection\nNorm2Projector() - compute 2-norm instead of projection\n\nIn order to help set up the calculation of the projected energy, where df.hproj should report dot(projector, ham, v), the keyword hproj accepts the following values (for ReportingStrategys passed to lomc!()):\n\n:auto - choose method depending on projector and ham (default)\n:lazy - compute dot(projector, ham, v) every time (slow)\n:eager -  precompute hproj as ham'*v (fast, requires adjoint(ham))\n:not - don't compute second projector (equivalent to nothing)\n\nExamples\n\nr_strat = EveryTimeStep(projector = copytight(svec))\n\nRecord the projected energy components df.vproj = svec⋅v and df.hproj = dot(svec,ham,v) with respect to the starting vector (performs fast eager calculation if Hamiltonians.LOStructure(ham) ≠ Hamiltonians.AdjointUnknown()), and report every time step.\n\nr_strat = EveryKthStep(k=10, projector = UniformProjector(), hproj = :lazy)\n\nRecord the projection of the instananeous coefficient vector v onto the uniform vector of all 1s into df.vproj and of ham⋅v into df.hproj, and report every kth time step.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.RunTillLastStep","page":"API","title":"Rimu.RunTillLastStep","text":"RunTillLastStep(step::Int = 0 # number of current/starting timestep\n             laststep::Int = 100 # number of final timestep\n             shiftMode::Bool = false # whether to adjust shift\n             shift = 0.0 # starting/current value of shift\n             dτ::Float64 = 0.01 # current value of time step\n) <: FciqmcRunStrategy\n\nParameters for running fciqmc!() for a fixed number of time steps. For alternative strategies, see FciqmcRunStrategy.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ScaledThresholdProject","page":"API","title":"Rimu.ScaledThresholdProject","text":"ScaledThresholdProject(threshold = 1.0) <: ProjectStrategy\n\nProject stochastically for walker amplitudes below threshold and scale configuration array as to keep the norm constant. As a consequence, the final configuration amplitudes may be smaller than threshold. See norm_project.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ShiftMemory","page":"API","title":"Rimu.ShiftMemory","text":"ShiftMemory(Δ::Int) <: MemoryStrategy\n\nEffectively replaces the fluctuating shift update procedure for the coefficient vector by an averaged shift over Δ timesteps, where Δ = 1 means no averaging.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ShiftStrategy","page":"API","title":"Rimu.ShiftStrategy","text":"Abstract type for defining the strategy for updating the shift with update_shift(). Implemented strategies:\n\nDoubleLogUpdate - default in lomc!()\nDontUpdate\nLogUpdate\nDelayedLogUpdate\nLogUpdateAfterTargetWalkers - FCIQMC standard\nDelayedLogUpdateAfterTargetWalkers\nDoubleLogUpdateAfterTargetWalkers\nDoubleLogUpdateAfterTargetWalkersSwitch\nHistoryLogUpdate\nDoubleLogProjected\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ThresholdProject","page":"API","title":"Rimu.ThresholdProject","text":"ThresholdProject(threshold = 1.0) <: ProjectStrategy\n\nProject stochastically for walker amplitudes below threshold. See norm_project.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.TimeStepStrategy","page":"API","title":"Rimu.TimeStepStrategy","text":"Abstract type for strategies for updating the time step with update_dτ(). Implemented strategies:\n\nConstantTimeStep\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T<:Real}","page":"API","title":"Rimu.apply_memory_noise!","text":"r = apply_memory_noise!(w, v, shift, dτ, pnorm, m_strat::MemoryStrategy)\n\nApply memory noise to w, i.e. w .+= r.*v, computing the noise r according to m_strat. Note that m_strat needs to be compatible with StochasticStyle(w). Otherwise, an error exception is thrown. See MemoryStrategy.\n\nw is the walker array after fciqmc step, v the previous one, pnorm the norm of v, and r the instantaneously applied noise.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.compute_proj_observables-Union{Tuple{RS}, Tuple{P2}, Tuple{P1}, Tuple{Any, Any, RS}} where {P1<:Nothing, P2<:Nothing, RS<:ReportingStrategy{P1, P2}}","page":"API","title":"Rimu.compute_proj_observables","text":"compute_proj_observables(v, ham, r::ReportingStrategy)\n\nCompute the projection of r.projector⋅v and r.hproj⋅v or r.projector⋅ham*v according to the ReportingStrategy r.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.fciqmc!-Union{Tuple{T}, Tuple{Any, FciqmcRunStrategy{T}, Any, Rimu.ShiftStrategy}, Tuple{Any, FciqmcRunStrategy{T}, Any, Rimu.ShiftStrategy, ReportingStrategy}, Tuple{Any, FciqmcRunStrategy{T}, Any, Rimu.ShiftStrategy, ReportingStrategy, TimeStepStrategy}, Tuple{Any, FciqmcRunStrategy{T}, Any, Rimu.ShiftStrategy, ReportingStrategy, TimeStepStrategy, Any}} where T","page":"API","title":"Rimu.fciqmc!","text":"fciqmc!(v, pa::FciqmcRunStrategy, [df,]\n         ham, s_strat::ShiftStrategy,\n         [r_strat::ReportingStrategy, τ_strat::TimeStepStrategy, w])\n-> df\n\nPerform the FCIQMC algorithm for determining the lowest eigenvalue of ham. v can be a single starting vector of type :<AbstractDVec or a vector of such structures. In the latter case, independent replicas are constructed. Returns a DataFrame df with statistics about the run, or a tuple of DataFrames for a replica run. Strategies can be given for updating the shift (see ShiftStrategy) and (optionally), for reporting (see ReportingStrategy), and for updating the time step dτ (see TimeStepStrategy).\n\nA pre-allocated data structure w for working memory can be passed as argument, and controls multi-threading behaviour. By default multi-threading is turned on. To turn multi-threading off, pass similar(localpart(v)) for w.\n\nThis function mutates v, the parameter struct pa as well as df, and w.\n\nNOTE: The function fciqmc!() may be deprecated soon. Change all scripts to call lomc!() instead!\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T<:Real}","page":"API","title":"Rimu.fciqmc_col!","text":"fciqmc_col!(w, ham, add, num, shift, dτ)\nfciqmc_col!(::Type{T}, args...)\n-> spawns, deaths, clones, antiparticles, annihilations\n\nSpawning and diagonal step of FCIQMC for single column of ham. In essence it computes\n\nw .+= (1 .+ dτ.*(shift .- ham[:,add])).*num.\n\nDepending on T ==StochasticStyle(w), a stochastic or deterministic algorithm will be chosen. The possible values for T are:\n\nIsDeterministic() deteministic algorithm\nIsStochastic() stochastic version where the changes added to w are purely integer, according to the FCIQMC algorithm\nIsStochasticWithThreshold(c) stochastic algorithm with floating point walkers.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.fciqmc_step!","page":"API","title":"Rimu.fciqmc_step!","text":"fciqmc_step!(Ĥ, v, shift, dτ, pnorm, w;\n                      m_strat::MemoryStrategy = NoMemory()) -> ṽ, w̃, stats\n\nPerform a single matrix(/operator)-vector multiplication:\n\ntildev = 1 - dτ(hatH - S)v \n\nwhere Ĥ == ham and S == shift. Whether the operation is performed in stochastic, semistochastic, or determistic way is controlled by the trait StochasticStyle(w). See StochasticStyle. w is a local data structure with the same size and type as v and used for working. Both v and w are modified.\n\nReturns the result ṽ, a (possibly changed) reference to working memory w̃,  and the array stats = [spawns, deaths, clones, antiparticles, annihilations]. Stats will contain zeros when running in deterministic mode.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Rimu.lomc!-Tuple{NamedTuple}","page":"API","title":"Rimu.lomc!","text":"lomc!(nt::NamedTuple, laststep::Int = nt.params.laststep)\n\nLinear operator Monte Carlo: Call signature for a continuation run.\n\nnt should have the same structure as the return value of lomc!(). The optional argument laststep can be used to set a new last step. If laststep > nt.params.step, additional time steps will be computed and the statistics in the DataFrame nt.df will be appended.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.lomc!-Union{Tuple{T}, Tuple{Any, Any}} where T","page":"API","title":"Rimu.lomc!","text":"lomc!(ham, v; kwargs...)\n-> nt::NamedTuple\n\nLinear operator Monte Carlo: Perform the FCIQMC algorithm for determining the lowest eigenvalue of ham. v can be a single starting vector of (wrapped) type :<AbstractDVec, or a vector of such structures for a replica simulation. Returns a named tuple containg all information required for continuation runs. In particular, nt.df is a DataFrame with statistics about the run, or a tuple of DataFrames for a replica run.\n\nKeyword arguments, defaults, and precedence:\n\nlaststep - can be used to override information otherwise contained in params\nthreading = :auto - can be used to control the use of multithreading (overridden by wm)\n:auto - use multithreading if s_strat.targetwalkers ≥ 500\ntrue - use multithreading if available (set shell variable JULIA_NUM_THREADS!)\nfalse - run on single thread\nwm - working memory; if set, it controls the use of multithreading and overrides threading; is mutated\nparams::FciqmcRunStrategy = RunTillLastStep(laststep = 100) - contains basic parameters of simulation state, see FciqmcRunStrategy; is mutated\ns_strat::ShiftStrategy = DoubleLogUpdate(targetwalkers = 1000) - see ShiftStrategy\nr_strat::ReportingStrategy = EveryTimeStep() - see ReportingStrategy\nτ_strat::TimeStepStrategy = ConstantTimeStep() - see TimeStepStrategy\nm_strat::MemoryStrategy = NoMemory() - see MemoryStrategy\np_strat::ProjectStrategy = NoProjection() - see ProjectStrategy\n\nReturn values\n\nnt = lomc!(args...)\n\nThe named tuple nt contains the following fields:\n\nnt = (\n    ham = ham, # the linear operator, from input\n    v = v, # the current coefficient vector, mutated from input\n    params = params, # struct with state parameters, mutated from input\n    df = df, # DataFrame with statistics per time step\n    wm = wm, # working memory, mutated from input\n    s_strat = s_strat, # from input\n    r_strat = r_strat, # from input\n    τ_strat = τ_strat, # from input\n    m_strat = m_strat, # from input\n    p_strat = p_strat, # from input\n)\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.norm_project!-Tuple{ProjectStrategy, Any, Vararg{Any, N} where N}","page":"API","title":"Rimu.norm_project!","text":"norm_project!(p_strat::ProjectStrategy, w, shift, pnorm) -> walkernumber\n\nCompute the walkernumber of w and update the coefficient vector w according to p_strat.\n\nThis may include stochastic projection of the coefficients to s.threshold preserving the sign depending on StochasticStyle(w) and p_strat. See ProjectStrategy.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.refine_r_strat-Tuple{ReportingStrategy, Any}","page":"API","title":"Rimu.refine_r_strat","text":"Rimu.refine_r_strat(r_strat::ReportingStrategy, ham)\n\nRefine the reporting strategy by replacing Symbols in the keyword argument hproj by the appropriate value. See ReportingStrategy\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.report!-Tuple{DataFrames.DataFrame, Tuple, EveryTimeStep}","page":"API","title":"Rimu.report!","text":"report!(df::DataFrame, t::Tuple, s<:ReportingStrategy)\n\nRecord results in df and write informational messages according to strategy s. See ReportingStrategy.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.sort_into_targets!-Tuple{Any, Any, Any}","page":"API","title":"Rimu.sort_into_targets!","text":"sort_into_targets!(target, source, stats) -> agg, wm, agg_stats\n\nAggregate coefficients from source to agg and from stats to agg_stats according to thread- or MPI-level parallelism. wm passes back a reference to working memory.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}","page":"API","title":"Rimu.update_dτ","text":"update_dτ(s<:TimeStepStrategy, dτ, args...) -> new dτ\n\nUpdate the time step according to the strategy s.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.update_shift-Tuple{HistoryLogUpdate, Any, Any, Any, Any, Any, Any, Any, Vararg{Any, N} where N}","page":"API","title":"Rimu.update_shift","text":"update_shift(s <: ShiftStrategy, shift, shiftMode, tnorm, pnorm, dτ, step, df, v_new, v_old)\n\nUpdate the shift according to strategy s. See ShiftStrategy.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.walkernumber-Tuple{Any}","page":"API","title":"Rimu.walkernumber","text":"walkernumber(w)\n\nCompute the number of walkers in w. In most cases this is identical to norm(w,1). For coefficient vectors with StochasticStyle(w) == IsStochastic2Pop it reports the one norm separately for the real and the imaginary part as a ComplexF64.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Reexported-Submodules","page":"API","title":"Reexported Submodules","text":"","category":"section"},{"location":"API.html#Hamiltonians","page":"API","title":"Hamiltonians","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Link to Module Hamiltionians.jl","category":"page"},{"location":"API.html#BitStringAddresses","page":"API","title":"BitStringAddresses","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [BitStringAddresses]","category":"page"},{"location":"API.html#Rimu.BitStringAddresses.AbstractFockAddress","page":"API","title":"Rimu.BitStringAddresses.AbstractFockAddress","text":"AbstractFockAddress\n\nSupertype representing a Fock state.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.BitString","page":"API","title":"Rimu.BitStringAddresses.BitString","text":"BitString{B,N} <: AbstractBitString\n\nType for storing bitstrings of static size. Holds B bits in N chunks, where each chunk is an UInt64\n\nN is chosen automatically to accommodate B bits as efficiently as possible.\n\nConstructors\n\nBitString{B,N}(::SVector{N,T}): unsafe constructor. Does not check for ghost bits.\nBitString{B,N}(i::UInt64): as above, but sets i as the rightmost chunk.\nBitString{B}(::Integer): Convert integer to BitString. Integer is truncated to the correct number of bits.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.BoseFS","page":"API","title":"Rimu.BitStringAddresses.BoseFS","text":"BoseFS{N,M,S} <: AbstractFockAddress\nBoseFS(bs::S) where S <: BitAdd\nBoseFS(bs::S, b)\n\nAddress type that represents a Fock state of N spinless bosons in M orbitals by wrapping a bitstring of type S. Orbitals are stored in reverse order, i.e. the first orbital in a BoseFS is stored rightmost in the bitstring bs. If the number of significant bits b is not encoded in S it must be passed as an argument (e.g. for BSAdd64 and BSAdd128).\n\nConstructors\n\nBoseFS{N,M}(::BitString): Unsafe constructor. Does not check whether the number of ones in a is equal to N.\nBoseFS(::BitString): Automatically determine N and M. This constructor is not type stable!\nBoseFS{[N,M,S]}(onr): Create BoseFS{N,M} from onr representation. This is efficient as long as at least N is provided.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.BoseFS2C","page":"API","title":"Rimu.BitStringAddresses.BoseFS2C","text":"BoseFS2C{NA,NB,M,AA,AB} <: AbstractFockAddress\n\nAddress type that constructed with two BoseFS{N,M,S}. It represents a Fock state with two components, e.g. two different species of bosons with particle number NA from species S and particle number NB from species B. The number of orbitals M is expected to be the same for both components.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.OccupiedOrbitalIterator","page":"API","title":"Rimu.BitStringAddresses.OccupiedOrbitalIterator","text":"occupied_orbitals(b)\n\nIterate over occupied orbitals in BoseFS address. Returns tuples of (boson_number, orbital_number, bit_offset).\n\nNote that the bit_offset is zero-based!\n\nExample\n\n```jldoctest julia> b = BoseFS((1,5,0,4)) julia> for (n, i) in occupied_orbitals(b)     @show n, i end (n, i) = (1, 1) (n, i) = (5, 2) (n, i) = (4, 4)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.check_bitstring_typeparams-Union{Tuple{N}, Tuple{B}, Tuple{Val{B}, Val{N}}} where {B, N}","page":"API","title":"Rimu.BitStringAddresses.check_bitstring_typeparams","text":"check_bitstring_typeparams(::Val{B}, ::Val{N})\n\nCheck if number of bits B is consistent with number of chunks N. Throw an error if not.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.chunk_bits-Tuple{Any, Any}","page":"API","title":"Rimu.BitStringAddresses.chunk_bits","text":"chunks_bits(s, i)\n\nNumber of bits in the i-th chunk of s.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.chunks-Tuple{BitString}","page":"API","title":"Rimu.BitStringAddresses.chunks","text":"chunks(::Type{<:BitString})\nchunks(s)\n\nSVector that stores the chunks of s.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.has_ghost_bits-Tuple{S} where S<:BitString","page":"API","title":"Rimu.BitStringAddresses.has_ghost_bits","text":"has_ghost_bits(s)\n\nCheck for bits outside data field.\n\nSee also: remove_ghost_bits.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.m_onr-Tuple{BoseFS}","page":"API","title":"Rimu.BitStringAddresses.m_onr","text":"m_onr(bs)\n\nCompute and return the occupation number representation of the bit string address bs as an MVector{M,Int32}, where M is the number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{var\"#s8\"} where var\"#s8\"<:(BoseFS{N, M, S} where S<:BitString)}, Tuple{M}, Tuple{N}} where {N, M}","page":"API","title":"Rimu.BitStringAddresses.nearUniform","text":"nearUniform(BoseFS{N,M})\nnearUniform(BoseFS{N,M,S}) -> bfs::BoseFS{N,M,S}\n\nCreate bosonic Fock state with near uniform occupation number of M modes with a total of N particles. Specifying the bit address type S is optional.\n\nExamples\n\njulia> nearUniform(BoseFS{7,5,BitString{14}})\nBoseFS((2,2,1,1,1))\n\njulia> nearUniform(BoseFS{7,5})\nBoseFS((2,2,1,1,1))\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.nearUniformONR-Tuple{Number, Number}","page":"API","title":"Rimu.BitStringAddresses.nearUniformONR","text":"nearUniformONR(N, M) -> onr::SVector{M,Int}\n\nCreate occupation number representation onr distributing N particles in M modes in a close-to-uniform fashion with each orbital filled with at least N ÷ M particles and at most with N ÷ M + 1 particles.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_bits-Union{Tuple{Type{var\"#s8\"} where var\"#s8\"<:(BitString{B, N} where N)}, Tuple{B}} where B","page":"API","title":"Rimu.BitStringAddresses.num_bits","text":"num_bits(::Type{<:BitString})\nnum_bits(s::BitString)\n\nTotal number of bits stored in bitstring.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Type{var\"#s6\"} where var\"#s6\"<:(BitString{var\"#s1\", N} where var\"#s1\")}, Tuple{N}} where N","page":"API","title":"Rimu.BitStringAddresses.num_chunks","text":"num_chunks(::Type{<:BitString})\nnum_chunks(s::BitString)\n\nNumber of chunks in bitstring. Equivalent to length(chunks(s)).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Val{B}}, Tuple{B}} where B","page":"API","title":"Rimu.BitStringAddresses.num_chunks","text":"num_chunks(::Val{B})\n\nDetermine the number of chunks needed to store B bits.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_modes-Tuple{AbstractFockAddress}","page":"API","title":"Rimu.BitStringAddresses.num_modes","text":"num_modes(::Type{<:AbstractFockAddress})\n\nNumber of modes represented by address.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_particles-Tuple{AbstractFockAddress}","page":"API","title":"Rimu.BitStringAddresses.num_particles","text":"num_particles(::Type{<:AbstractFockAddress})\n\nNumber of particles represented by address.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.onr-Tuple{BoseFS}","page":"API","title":"Rimu.BitStringAddresses.onr","text":"onr(bs)\n\nCompute and return the occupation number representation of the bit string address bs as an SVector{M,Int32}, where M is the number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.remove_ghost_bits-Tuple{S} where S<:BitString","page":"API","title":"Rimu.BitStringAddresses.remove_ghost_bits","text":"remove_ghost_bits(s)\n\nRemove set bits outside data field if any are present.\n\nSee also: has_ghost_bits.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.top_chunk_bits-Union{Tuple{Type{var\"#s8\"} where var\"#s8\"<:(BitString{B, N} where N)}, Tuple{B}} where B","page":"API","title":"Rimu.BitStringAddresses.top_chunk_bits","text":"top_chunk_bits(::Type{<:BitString})\ntop_chunk_bits(s::BitString)\n\nNumber of bits stored in top chunk. Equivalent to chunk_bits(s, 1).\n\n\n\n\n\n","category":"method"},{"location":"API.html#DictVectors","page":"API","title":"DictVectors","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [DictVectors]","category":"page"},{"location":"API.html#Rimu.DictVectors","page":"API","title":"Rimu.DictVectors","text":"Module that provides data structures that behave similar to sparse vectors, but are indexed by arbitrary types (could be non-integers) similarly to dictionaries. The idea is to do linear algebra with data structures that are neither subtyped to AbstractVector nor to AbstractDict and are suitable for use with KrylovKit.jl. For this, the abstract type and interface AbstractDVec is provided, with the following concrete subtypes:\n\nDVec\nDFVec\nFastDVec\n\n\n\n\n\n","category":"module"},{"location":"API.html#Rimu.DictVectors.AbstractDVec","page":"API","title":"Rimu.DictVectors.AbstractDVec","text":"DictVectors.AbstractDVec{K,V}\n\nAbstract type for sparse vectors with valtype() V based on dictionary-like structures. They behave like vectors except that indexing is performed with an arbitrary keytype() K (no order required). getindex() returns zero(V) for any unknown key and zeroed elements should be deleted with delete!(). Thus, iteration typically returns only non-zero entries. In variance to AbstractVector, length() will return the number of non-zero elements, while capacity() returns the holding capacity (assumed fixed) of the object. Even though AbstractDVec is similar to both AbstractDict and AbstractVector, it is explicitly not subtyped to either. The aim is to create data structures suitable for FCIQMC and compatible with KrylovKit.jl.\n\nInterface\n\nThe interface is similar to the AbstractDict interface. Implement what would be needed for the AbstractDict interface (setindex!, getindex, delete!, length, haskey, empty!, isempty) and, in addition:\n\ncapacity(dv): holding capacity\nsimilar(dv [,Type])\niterate(): should return values of type V\npairs(): should return an iterator over key::K => content pairs. If content ≠ value::V then provide values() iterator as well!\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.AbstractProjector","page":"API","title":"Rimu.DictVectors.AbstractProjector","text":"Abstract supertype for projectors to be used in in lieu of DVecs or Vectors.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.DFVec","page":"API","title":"Rimu.DictVectors.DFVec","text":"DFVec{K,V,F}(capacity) <: AbstractDVec{K,V <: Number}\nDFVec(key => (value, flag); capacity)\nDFVec(args...; capacity)\nDFVec(d::Dict [, capacity])\nDFVec(v::Vector{V} [, capacity])\n\nDictionary-based vector-like data structure with minimum capacity capacity for storing values and flags with keys. The values have type eltype(dv) == V and the flags have flagtype(dv) == F. Indexing is done with an arbitrary (in general non-integer) key with keytype(dv) == K. If the keyword argument capacity is passed then args are parsed as for Dict. When constructed from a Vector{V}, the keys will be integers ∈ [1, length(v)] and the flag zero(UInt16). See AbstractDVec. The method capacity() is defined but not a strict upper limit as Dict objects can expand.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.DVec","page":"API","title":"Rimu.DictVectors.DVec","text":"DVec{K,V}(capacity) <: AbstractDVec{K,V}\nDVec(key => value; capacity)\nDVec(args...; capacity)\nDVec(d::Dict [, capacity])\nDVec(v::Vector{V} [, capacity])\n\nDictionary-based vector-like data structure with minimum capacity capacity for storing values with keys. The type of the values is eltype(dv) == V. Indexing is done with an arbitrary (in general non-integer) key with keytype(dv) == K. If the keyword argument capacity is passed then args are parsed as for Dict. When constructed from a Vector, the keys will be integers ∈ [1, length(v)]. See AbstractDVec. The method capacity() is defined but not a strict upper limit as Dict objects can expand.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.DVec2","page":"API","title":"Rimu.DictVectors.DVec2","text":"DVec2{K,V,D<:AbstractDict{K,V},S}\n\nFunctionally equivalent to DVec, but with the following changes:\n\nAny AbstractDict can be used for storage. To use this feature construct the DVec2 as DVec2(dict, capacity[, style]).\nSupports a style keyword argument that sets the StochasticStyle.\n\nConstructors:\n\nDVec2(dict::AbstractDict, capacity[, style]): create a DVec2 with dict for storage. Note that the data is not copied. Modifying the DVec2 will also modify dict.\nDVec2(args...; capacity[, style]): args... are passed to the Dict constructor. The Dict is used for storage.\nDVec2{K,V}(capacity[, style]): create an empty DVec2{K,V}.\nDVec2(::AbstractVector{T}[, capacity, style]): create a DVec2{Int,T} from an array.  Capacity defaults to the length of the array\nDVec2(adv::AbstractDVec[, capacity, style]): create a DVec2 with the same contents as  adv. capacity and style are inherited from adv by default.\n\nIn most cases, the default value for style is determined based on the resulting DVec2's eltype. See also default_style.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.FDVPairsIterator","page":"API","title":"Rimu.DictVectors.FDVPairsIterator","text":"FDVPairsIterator\n\nIterator type for pairs from a AbstractDVec.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.FastDVec","page":"API","title":"Rimu.DictVectors.FastDVec","text":"DictVectors.FastDVec{K,V}(capacity)\n\nCreate a dictionary-like array indexed by keys of type K and values of type V with a maximum capacity of capacity.\n\nFastDVec(a::AbstractArray, [capacity = length(a)])\nFastDVec(d::AbstractDict{K,V}, [capacity = length(d)])\nFastDVec(d::AbstractDVec{K,V}, [capacity = length(d)])\n\nConstruct a FastDVec object from an existing array or dictionary.\n\nFastDVec(args...; capacity)\n\nIf the keyword argument capacity is passed then args are parsed as for Dict.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.FlagsIterator","page":"API","title":"Rimu.DictVectors.FlagsIterator","text":"FlagsIterator\n\nIterator type returned by flags().\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsDeterministic","page":"API","title":"Rimu.DictVectors.IsDeterministic","text":"IsDeterministic()\n\nTrait for generalised vector of configuration indicating deterministic propagation of walkers.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsDynamicSemistochastic","page":"API","title":"Rimu.DictVectors.IsDynamicSemistochastic","text":"IsDynamicSemistochastic\n\nSimilar to IsStochasticWithThreshold, but does exact spawning when the number of walkers in a configuration is high.\n\nParameters:\n\nrel_threshold = 1.0: If the walker number on a configuration times this threshold is greater than the number of offdiagonals, spawning is done deterministically. Should be set to at most 1 for best performance.\nabs_threshold = Inf: If the walker number on a configuration is greater than this value, spawning is done deterministically. Can be set to e.g abs_threshold = 0.1 * target_walkers.\nproj_threshold = 1.0: Values below this number are stochastically projected to this value or zero. See also IsStochasticWithThreshold.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsSemistochastic","page":"API","title":"Rimu.DictVectors.IsSemistochastic","text":"IsSemistochastic(threshold::Float16, d_space)\n\nTrait for generalised vector of configurations indicating semistochastic propagation. Set with setSemistochastic!.\n\n> StochasticStyle(V) = IsSemistochastic(threshold, d_space)\n\nwhere d_space is a vector of addresses defining the the stochastic subspace.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsStochastic","page":"API","title":"Rimu.DictVectors.IsStochastic","text":"IsStochastic()\n\nTrait for generalised vector of configurations indicating stochastic propagation as seen in the original FCIQMC algorithm.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsStochastic2Pop","page":"API","title":"Rimu.DictVectors.IsStochastic2Pop","text":"IsStochastic2Pop()\n\nTrait for generalised vector of configurations indicating stochastic propagation with complex walker numbers representing two populations of integer walkers.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsStochastic2PopInitiator","page":"API","title":"Rimu.DictVectors.IsStochastic2PopInitiator","text":"IsStochastic2PopInitiator()\n\nTrait for generalised vector of configurations indicating stochastic propagation with complex walker numbers representing two populations of integer walkers. Initiator algorithm will be used.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsStochastic2PopWithThreshold","page":"API","title":"Rimu.DictVectors.IsStochastic2PopWithThreshold","text":"IsStochastic2PopWithThreshold(threshold::Float32)\n\nTrait for generalised vector of configurations indicating stochastic propagation with complex walker numbers representing two populations of real walkers and cutoff threshold.\n\n> StochasticStyle(V) = IsStochastic2PopWithThreshold(threshold)\n\nDuring stochastic propagation, walker numbers small than threshold will be stochastically projected to either zero or threshold.\n\nThe trait can be conveniently defined on an instance of a generalised vector with the function setThreshold. Example:\n\njulia> dv = DVec(nearUniform(BoseFS{3,3}) => 2.0+3.0im; capacity = 10)\njulia> setThreshold(dv, 0.6)\njulia> StochasticStyle(dv)\nIsStochastic2PopWithThreshold(0.6f0)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsStochasticWithThreshold","page":"API","title":"Rimu.DictVectors.IsStochasticWithThreshold","text":"IsStochasticWithThreshold(threshold::Float32)\n\nTrait for generalised vector of configurations indicating stochastic propagation with real walker numbers and cutoff threshold.\n\n> StochasticStyle(V) = IsStochasticWithThreshold(threshold)\n\nDuring stochastic propagation, walker numbers small than threshold will be stochastically projected to either zero or threshold.\n\nThe trait can be conveniently defined on an instance of a generalised vector with the macro @setThreshold. Example:\n\njulia> dv = DVec(Dict(nearUniform(BoseFS{3,3})=>3.0))\njulia> @setThreshold dv 0.6\njulia> StochasticStyle(dv)\nIsStochasticWithThreshold(0.6f0)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.KVPairsIterator","page":"API","title":"Rimu.DictVectors.KVPairsIterator","text":"KVPairsIterator\n\nIterator type returned by kvpairs().\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.Norm2Projector","page":"API","title":"Rimu.DictVectors.Norm2Projector","text":"Norm2Projector()\n\nResults in computing the two-norm when used in dot(). E.g.\n\ndot(NormProjector(),x)\n-> norm(x,2) # with type Float64\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.NormProjector","page":"API","title":"Rimu.DictVectors.NormProjector","text":"NormProjector()\n\nResults in computing the one-norm when used in dot(). E.g.\n\ndot(NormProjector(),x)\n-> norm(x,1) # with type valtype(x)\n\nNormProjector() thus represents the vector sign.(x).\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.StochasticStyle","page":"API","title":"Rimu.DictVectors.StochasticStyle","text":"StochasticStyle(v)\nStochasticStyle(typeof(v))\n\nStochasticStyle specifies the native style of the generalised vector v that determines how simulations are to proceed. This can be fully stochastic (with IsStochastic), fully deterministic (with IsDeterministic), or stochastic with floating point walker numbers and threshold (with IsStochasticWithThreshold).\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.UniformProjector","page":"API","title":"Rimu.DictVectors.UniformProjector","text":"UniformProjector()\n\nRepresents a vector with all elements 1. To be used with dot(). Minimizes memory allocations.\n\nUniformProjector()⋅v == sum(v)\ndot(UniformProjector(), LO, v) == sum(LO*v)\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Base.fill!-Union{Tuple{V}, Tuple{K}, Tuple{AbstractDVec{K, V}, V}} where {K, V}","page":"API","title":"Base.fill!","text":"fill!(da::AbstractDVec, x)\n\nEmpties da if x==zero(valtype(da)) and throws an error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Base.get-Tuple{DFVec, Any, Tuple}","page":"API","title":"Base.get","text":"get(dv::DFVec, key, deftup::Tuple)\n\nReturn tuple containing value and flag if key exists and otherwise deftup.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Base.get-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K, V, F}, Any, Number}} where {K, V, F}","page":"API","title":"Base.get","text":"get(dv::DFVec, key, defnum::Number)\n\nReturn value only if key exists and otherwise defnum\n\n\n\n\n\n","category":"method"},{"location":"API.html#Base.isequal-Tuple{AbstractDVec, AbstractDVec}","page":"API","title":"Base.isequal","text":"isequal(l::AbstractDVec, r::AbstractDVec)\n\nReturns true if all non-zero entries have the same value. Equality of flags is not tested unless both l and r support flags.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Base.isequal-Tuple{DFVec, DFVec}","page":"API","title":"Base.isequal","text":"isequal(l::DFVec, r::DFVec)\n\nReturns true if all non-zero entries have the same value and the same flag.\n\n\n\n\n\n","category":"method"},{"location":"API.html#LinearAlgebra.axpy!-Tuple{Number, AbstractDVec, AbstractDVec}","page":"API","title":"LinearAlgebra.axpy!","text":"axpy!(α::Number, X::AbstractDVec, Y::AbstractDVec)\naxpy!(α::Number, X::AbstractDVec, Ys::Tuple, batchsize)\n\nOverwrite Y with α*X + Y where α is scalar for AbstractDVecs. If a tuple Ys is passed with Threads.nthreads() AbstractDVecs, then perform the operation in parallel over threads with batchsize elements at a time.\n\n\n\n\n\n","category":"method"},{"location":"API.html#LinearAlgebra.norm-Tuple{AbstractDVec, Real}","page":"API","title":"LinearAlgebra.norm","text":"norm(x::AbstractDVec, p)\n\nComputes the p-norm of the DVec x. Implemented for p ∈ {1, 2, Inf}. Returns zero if x is empty.\n\n\n\n\n\n","category":"method"},{"location":"API.html#LinearAlgebra.norm-Tuple{AbstractDVec}","page":"API","title":"LinearAlgebra.norm","text":"norm(x::AbstractDVec{K,V})\n\nComputes the 2-norm of the DVec x.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.add!-Union{Tuple{V2}, Tuple{V1}, Tuple{K}, Tuple{AbstractDVec{K, V1}, AbstractDVec{K, V2}}} where {K, V1, V2}","page":"API","title":"Rimu.DictVectors.add!","text":"add!(x::AbstractDVec,y::AbstactDVec)\n\nInplace add x+y and store result in x.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.capacity","page":"API","title":"Rimu.DictVectors.capacity","text":"DictVectors.capacity(dv::AbstractDVec, [s = :effective])\ncapacity(dvs::Tuple, [s = :effective])\n\ngives the effective holding capacity of dv. If a tuple of dvs is given it aggregates the capacities.\n\nOptional argument s:\n\n:effective  the number of elements that\n\ncan be stored savely (default)\n\n:allocated actual internal memory allocation\n\n\n\n\n\n","category":"function"},{"location":"API.html#Rimu.DictVectors.clearDFlags!-Tuple{Any}","page":"API","title":"Rimu.DictVectors.clearDFlags!","text":"clearDFlags!(dv)\n\nClear all flags in dv of the deterministic bit (rightmost bit).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.copytight-Tuple{AbstractDVec}","page":"API","title":"Rimu.DictVectors.copytight","text":"copytight(v)\n\nCreate a shallow copy of v using as little memory as possible. Specifically, if v isa AbstractDVec, the capacity of the copy will be set to length(v).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.default_style-Tuple{Type{var\"#s8\"} where var\"#s8\"<:Integer}","page":"API","title":"Rimu.DictVectors.default_style","text":"default_style(::Type)\n\nPick a StochasticStyle based on the type. Throws an error if no known default style is known.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.flags-Tuple{DFVec}","page":"API","title":"Rimu.DictVectors.flags","text":"flags(dv::DFVec)\n\nAn iterator that yields flags stored in the DFVec dv.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.gettuple-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K, V, F}, Any}} where {K, V, F}","page":"API","title":"Rimu.DictVectors.gettuple","text":"gettuple(dv::DFVec, key)\n\nRetrieve the tuple (v,f) stored at the given key. If the key is not found, return a tuple of zeros.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.kvpairs-Tuple{Any}","page":"API","title":"Rimu.DictVectors.kvpairs","text":"kvpairs(collection)\n\nReturn an iterator over key => value pairs ignoring any flags. If no flags are present, eg. for generic AbstractDVec, this falls back to Base.pairs.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.kvpairs-Tuple{DFVec}","page":"API","title":"Rimu.DictVectors.kvpairs","text":"kvpairs(dv::DFVec)\n\nAn iterator that yields key => value pairs stored in the DFVec dv ignoring any flags. In contrast, Base.pairs() will return pairs key => (value, flag).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.normInf-Tuple{AbstractDVec}","page":"API","title":"Rimu.DictVectors.normInf","text":"normInf(x::AbstractDVec)\n\nInfinity norm: largest absolute value of entries.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.norm_sqr-Union{Tuple{AbstractDVec{K, V}}, Tuple{V}, Tuple{K}} where {K, V<:Number}","page":"API","title":"Rimu.DictVectors.norm_sqr","text":"norm_sqr(x::AbstractDVec)\n\nFast calculation of the square of the 2-norm of x.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.pairtype-Tuple{Any}","page":"API","title":"Rimu.DictVectors.pairtype","text":"pairtype(dv)\n\nReturns the type of stored data, as returned by the pairs() iterator.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.setSemistochastic!-Tuple{Any, Float16, Any}","page":"API","title":"Rimu.DictVectors.setSemistochastic!","text":"setSemistochastic!(dv, threshold::Float16, d_space)\n\nSet the deterministic space for dv with threshold threshold, where d_space is a vector of addresses defining the the stochastic subspace.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.setThreshold-Tuple{Any, Any}","page":"API","title":"Rimu.DictVectors.setThreshold","text":"setThreshold(dv, threshold)\n\nSet a threshold for non-integer walker number FCIQMC. Technically, the function sets the trait StochasticStyle of the generalised vector dv to IsStochasticWithThreshold(threshold), where dv must be a type that supports floating point walker numbers. Also available as macro, see @setThreshold.\n\nExample usage:\n\njulia> dv = DVec(Dict(nearUniform(BoseFS{3,3})=>3.0))\njulia> setThreshold(dv, 0.6)\nIsStochasticWithThreshold(0.6f0)\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.tuples-Tuple{DFVec}","page":"API","title":"Rimu.DictVectors.tuples","text":"tuples(dv::DFVec)\n\nAn iterator that yields tuples (v, f) with value v and flag f stored in the DFVec dv.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.zero!-Tuple{AbstractDVec}","page":"API","title":"Rimu.DictVectors.zero!","text":"zero!(v::AbstractDVec)\n\nReplace v by a zero vector as an inplace operation. For AbstractDVec types it means removing all non-zero elements.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.@setDeterministic-Tuple{Any}","page":"API","title":"Rimu.DictVectors.@setDeterministic","text":"@setDeterministic dv\n\nA macro to undo the effect of [@setThreshold] and set the trait StochasticStyle of the generalised vector dv to IsDeterministic().\n\n\n\n\n\n","category":"macro"},{"location":"API.html#Rimu.DictVectors.@setThreshold-Tuple{Any, Any}","page":"API","title":"Rimu.DictVectors.@setThreshold","text":"@setThreshold dv threshold\n\nA macro to set a threshold for non-integer walker number FCIQMC. Technically, the macro sets the trait StochasticStyle of the generalised vector dv to IsStochasticWithThreshold(threshold), where dv must be a type that supports floating point walker numbers. Also available as function, see setThreshold.\n\nExample usage:\n\njulia> dv = DVec(Dict(nearUniform(BoseFS{3,3})=>3.0))\njulia> @setThreshold dv 0.6\nIsStochasticWithThreshold(0.6f0)\n\n\n\n\n\n","category":"macro"},{"location":"API.html#Blocking","page":"API","title":"Blocking","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [Blocking]","category":"page"},{"location":"API.html#Rimu.Blocking","page":"API","title":"Rimu.Blocking","text":"Blocking\n\nModule that contains functions performing the Flyvbjerg-Petersen (J. Chem. Phys. 91, 461 (1989)) blocking analysis for evaluating the standard error on a correlated data set. A \"M-test\" is also implemented based on Jonsson (Phys. Rev. E 98, 043304, (2018)).\n\n\n\n\n\n","category":"module"},{"location":"API.html#Rimu.Blocking.autoblock-Tuple{DataFrames.DataFrame}","page":"API","title":"Rimu.Blocking.autoblock","text":"autoblock(df::DataFrame; start = 1, stop = size(df)[1])\n-> s̄, σs, ē, σe, k\n\nDetermine mean shift s̄ and projected energy ē with respective standard errors σs and σe by blocking analsis from the DataFrame df returned from fciqmc!(). The number k of blocking steps and decorrelation time 2^k are obtained from the M-test for the shift and also applied to the projected energy, assuming that the projected quantities decorrelate on the same time scale. Only the real part of the shift is considered. Returns a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.autoblock-Tuple{Tuple}","page":"API","title":"Rimu.Blocking.autoblock","text":"autoblock(dftup::Tuple; start = 1, stop = size(dftup[1])[1])\n-> s̄1, σs1, s̄2, σs2, ē1, σe1, ē2, σe2, ēH, σeH, k\n\nReplica version. dftup is the tuple of DataFrames returned from replica fciqmc!(). Returns a named tuple with shifts and three variational energy estimators and respective errors obtained from blocking analysis. The larger of the k values from M-tests on the two shift time series is used.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.autocovariance-Tuple{Vector{T} where T, Int64}","page":"API","title":"Rimu.Blocking.autocovariance","text":"autocovariance(v::Vector,h::Int; corrected::Bool=true)\n\nhatgamma(h) =frac1nsum_t=1^n-h(v_t+h-barv)(v_t-barv)^* Calculate the autocovariance of dataset v with a delay h. If corrected is true (the default) then the sum is scaled with n-h, whereas the sum is scaled with n if corrected is false where n = length(v).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.blockAndMTest-Tuple{Vector{T} where T}","page":"API","title":"Rimu.Blocking.blockAndMTest","text":"v̄, σ, σσ, k, df = blockAndMTest(v::Vector)\n\nPerform a blocking analysis and M-test on v returning the mean v̄, standard error σ, its error σσ, the number of blocking steps k, and the DataFrame df with blocking data.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.blocker-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"API","title":"Rimu.Blocking.blocker","text":"blocker(v::Vector) -> new_v::Vector\n\nReblock the data by successively taking the mean of two adjacent data points to form a new vector with a half of the length(v). The last data point will be discarded if length(v) is odd.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.blocking-Union{Tuple{T2}, Tuple{T1}, Tuple{Vector{T1}, Vector{T2}}} where {T1, T2}","page":"API","title":"Rimu.Blocking.blocking","text":"blocking(x::Vector,y::Vector) -> df::DataFrame\n\nPerform a blocking analysis for the quotient of means x̄/ȳ from two data sets. If corrected is true (the default) then the sums in both variance and covariance are scaled with n-1, whereas the sums are scaled with n if corrected is false  where n = length(x) = length(y). Entries in returned dataframe:\n\nblocks = number of blocks in current blocking step;\nmean_x, SD_x, SE_x, SE_SE_x = the mean, standard deviation, standard error and error on standard error estimated for dataset x;\nmean_y, SD_y, SE_y, SE_SE_y = ditto. for dataset y;\nCovariance = the covariance between data in x and y;\nmean_f = x̄/ȳ;\nSE_f = standard error estimated for x̄/ȳ.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.blocking-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"API","title":"Rimu.Blocking.blocking","text":"blocking(v::Vector; corrected::Bool=true) -> df\n\nPerform a blocking analysis according to Flyvberg and Peterson JCP (1989) for single data set and return a DataFrame with statistical data for each blocking step. M-test data according to Jonsson PRE (2018) is also provided. If corrected is true (the default) then the sum in var is scaled with n-1 and in autocovariance is scaled with n-h, whereas the sum is scaled with n for both if corrected is false where n = length(v).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.blocking_old-Tuple{Vector{T} where T}","page":"API","title":"Rimu.Blocking.blocking_old","text":"blocking(v::Vector; typos = nothing) -> df\n\nPerform a blocking analysis according to Flyvberg and Peterson JCP (1989) for single data set and return a DataFrame with statistical data for each blocking step. M-test data according to Jonsson PRE (2018) is also provided.\n\nKeyword argument typos\n\ntypos = nothing - correct all presumed typos.\ntypos = :FP - use Flyvberg and Peterson (correct) standard error and Jonsson formul for M.\ntypos = :Jonsson - calculate M and standard error as written in Jonsson.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.combination_division-Tuple{Vector{T} where T, Vector{T} where T}","page":"API","title":"Rimu.Blocking.combination_division","text":"combination_division(x::Vector,y::Vector; corrected::Bool=true)\n\nFind the standard error on the quotient of means x̄/ȳ from two data sets, note that the standard errors are different on (xy) neq bar(fracxy). If corrected is true (the default) then the sums in both variance and covariance are scaled with n-1, whereas the sums are scaled with n if corrected is false  where n = length(x) = length(y).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.covariance-Tuple{Vector{T} where T, Vector{T} where T}","page":"API","title":"Rimu.Blocking.covariance","text":"covariance(x::Vector,y::Vector; corrected::Bool=true)\n\nCalculate the covariance between the two data sets x and y with equal length. If corrected is true (the default) then the sum is scaled with  n-1, whereas the sum is scaled with n if corrected is false  where n = length(x) = length(y).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.gW-Tuple{AbstractArray, AbstractArray, Any}","page":"API","title":"Rimu.Blocking.gW","text":"gW(norm::AbstractArray, shift::AbstractArray, dt, [b]; pad = :true) -> g\ngW(df::DataFrame, [b]; pad = :true) -> g\n\nCompute the growth witness\n\nG^(n) = S^(n) - fracvertmathbfc^(n+1)vert - vertmathbfc^(n)vertvertmathbfc^(n)vert dtau\n\nwhere S is the shift and vertmathbfc^(n)vert == norm[n, 1]. Setting b ≥ 1 a sliding average over b time steps is computed.\n\nIf pad is set to :false then the returned array g has the length length(norm) - b. If set to :true then g will be padded up to the same length as norm and shift.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.growthWitness-Tuple{AbstractArray, AbstractArray, Any}","page":"API","title":"Rimu.Blocking.growthWitness","text":"growthWitness(norm::AbstractArray, shift::AbstractArray, dt; b = 30, pad = :true) -> g\ngrowthWitness(df::DataFrame; b = 30, pad = :true) -> g\n\nCompute the growth witness\n\nG_b^(n) = S^(n) - fraclogvertmathbfc^(n+b)vert - logvertmathbfc^(n)vertb dtau\n\nwhere S̄ is an average of the shift over b time steps and vertmathbfc^(n)vert == norm[n]. The parameter b ≥ 1 averages the derivative quantity over b time steps and helps suppress noise.\n\nIf pad is set to :false then the returned array g has the length length(norm) - b. If set to :true then g will be padded up to the same length as norm and shift.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.mtest-Tuple{DataFrames.DataFrame}","page":"API","title":"Rimu.Blocking.mtest","text":"mtest(df::DataFrame; warn = true) -> k\n\nThe \"M test\" based on Jonsson, M. Physical Review E, 98(4), 043304, (2018). Expects df to be output of a blocking analysis with column df.M containing relevant M_j values, which are compared to a χ^2 distribution. Returns the row number k where the M-test is passed. If the M-test has failed mtest() returns the value -1 and optionally prints a warning message.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.se-Tuple{Vector{T} where T}","page":"API","title":"Rimu.Blocking.se","text":"se(v::Vector;corrected::Bool=true)\n\nCalculate the standard error of the dataset v. If corrected is true (the default) then the sum in std is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(v).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.Blocking.smoothen-Tuple{AbstractVector{T} where T, Any}","page":"API","title":"Rimu.Blocking.smoothen","text":"smoothen(noisy::AbstractVector, b; pad = :true)\n\nSmoothen the array noisy by averaging over a sliding window of length b. Pad to length(noisy) if pad == true. Otherwise, the returned array will have the length length(noisy) - b.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Unexported-Submodules","page":"API","title":"Unexported Submodules","text":"","category":"section"},{"location":"API.html#FastBufs","page":"API","title":"FastBufs","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [FastBufs]","category":"page"},{"location":"API.html#Rimu.FastBufs","page":"API","title":"Rimu.FastBufs","text":"Provides the FastBuf data structure.\n\n\n\n\n\n","category":"module"},{"location":"API.html#Rimu.FastBufs.FastBuf","page":"API","title":"Rimu.FastBufs.FastBuf","text":"FastBuf{T}(n)\n\nCreate a first-in-last-out buffer of maximum capacity n. The element type is T. Fill a FastBuf with push!(), retrieve with pop!(). Accessing elements with getindex() and setindex!() as well as iteration are also supported. Check the capacity of a FastBuf with capacity().\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.FastBufs.capacity-Tuple{FastBuf}","page":"API","title":"Rimu.FastBufs.capacity","text":"Gives the capacity of a FastBuf object.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ConsistentRNG","page":"API","title":"ConsistentRNG","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Link to Module ConsistentRNG.jl","category":"page"},{"location":"API.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"","category":"page"}]
}
