var documenterSearchIndex = {"docs":
[{"location":"index.html#Rimu.jl-Package-Guide","page":"Guide","title":"Rimu.jl Package Guide","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"Random Integrators for many-body quantum systems","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"The grand aim is to develop a toolbox for many-body quantum systems that can be represented by a Hamiltonian in second quantisation language. Currently there are tools to find the ground state with FCIQMC or with a Lanczos algorithm (using KrylovKit for small Hilbert spaces). We will add tools to solve the time-dependent Schrödinger equation and Master equations for open system time evolution.","category":"page"},{"location":"index.html#Contents","page":"Guide","title":"Contents","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"Pages = [\"index.md\",\"hamiltonians.md\",\"consistentrng.md\",\"documentation.md\",\n            \"testing.md\",\"API.md\",\"BHM-example.md\"]\nDepth = 4","category":"page"},{"location":"index.html#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"index.html#Install-Rimu-for-usage","page":"Guide","title":"Install Rimu for usage","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"Rimu can be installed with the package manager directly from the github repository. Either hit the ] key at the Julia REPL to get into Pkg mode and type","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"pkg> add https://github.com/joachimbrand/Rimu.jl#master","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"where master can be exchanged with the name of the desired git branch. Alternatively, use","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"julia> using Pkg; Pkg.add(PackageSpec(url=\"https://github.com/joachimbrand/Rimu.jl\", rev=\"master\"))","category":"page"},{"location":"index.html#Install-Rimu-for-development","page":"Guide","title":"Install Rimu for development","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"In order to be able to edit the source code, push changes, change and make new git branches, etc., clone the git repository with git clone to a convenient location, e.g. ~/mygitpackagefolder/. Then hit the ] key at the Julia REPL to get into Pkg mode and type","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"pkg> develop ~/mygitpackagefolder/rimu.jl","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"where the file path has to be adjusted to the location of the cloned git repository.","category":"page"},{"location":"index.html#Usage","page":"Guide","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"The package is now installed and can be imported with","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"julia> using Rimu","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"When planning to edit the code of the package it is advisable to use the Revise package by issuing","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"julia> using Revise","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"before using Rimu. This will track any changes made to the source code of Rimu and the changed package will be available after saving the source code (hopefully, and most of the time, without restarting the Julia REPL).","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Rimu offers a number of tools for representing Hamiltonians (see Hamiltonians) and state vectors / wave functions (see DictVectors) as well as algorithms to find the ground state, e.g. lomc!.","category":"page"},{"location":"index.html#Scripts","page":"Guide","title":"Scripts","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"Rimu is written as a Julia package to be imported with using Rimu as described above. It supplies useful functions and types. Performing actual calculations and analysing the results is done with scripts. The folder scripts/ contains a collections of scripts that are either examples for use of the Rimu package or useful scripts for data analysis. In particular:","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"scripts/BHM-example.jl is an example script that runs fciqmc on the 1D Bose-Hubbard model. A data frame with results is written to the file fciqmcdata.feather.\nscripts/BHM-example-mpi.jl is an example script that runs the same fciqmc calculation as above with MPI enabled.\nscripts/read_file_and_plot.jl reads the feather file (from the working directory) and displays basic plots and blocking analysis of the shift.\nplotting.jl is a collection of (currently very primitive) plotting function. On purpose these are not part of the Rimu package in order to avoid a dependency on a plotting package.","category":"page"},{"location":"index.html#MPI","page":"Guide","title":"MPI","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"The Rimu package can run in parallel on different processes or node and distribute work by making use of MPI, or \"message passing interface\". For example, running","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"> julia scripts/BHM-example.jl","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"will run on one processor with the main lomc!() computation (i.e. after package loading and compilation) completing in 2.69 seconds.","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Running","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"> mpirun -np 4 julia scripts/BHM-example-mpi.jl","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"on the same hardware makes use of 4 cores and the main part completes in 1.04 seconds, a speedup factor of 2.6. This seems reasonable, given that extra work needs to be done for communicating between different processes.","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Initialising and finalising MPI communication has to be handled at the script level. Enabling MPI communication for use in lomc!() is done by wrapping the primary data structures as MPIData. A number of different strategies for data communication are implemented and most easily accessed with the functions:","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"mpi_default\nmpi_one_sided\nmpi_no_exchange","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"See examples in the Scripts folder.","category":"page"},{"location":"index.html#References","page":"Guide","title":"References","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"The code implements the FCIQMC algorithm described in","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"\"Fermion Monte Carlo without fixed nodes: A game of life, death, and annihilation in Slater determinant space\", G. H. Booth, A. J. W. Thom, A. Alavi, J. Chem. Phys. 131, 054106 (2009).","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Scientific papers using the Rimu code:","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"\"Improved walker population control for full configuration interaction quantum Monte Carlo\", M. Yang, E. Pahl, J. Brand, J. Chem. Phys. 153, 170143 (2020); DOI: 10.1063/5.0023088; arXiv:2008.01927.","category":"page"},{"location":"hamiltonians.html#Developer-Documentation","page":"Hamiltonians","title":"Developer Documentation","text":"","category":"section"},{"location":"hamiltonians.html#Module-Hamiltionians.jl","page":"Hamiltonians","title":"Module Hamiltionians.jl","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"This module contains definitions of Hamiltonians, in particular specific physical models of interest. These are organised by means of an interface around the abstract type AbstractHamiltonian, in the spirit of the AbstractArray interface as discussed in the Julia Documentation.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"Hamiltonians","category":"page"},{"location":"hamiltonians.html#Rimu.Hamiltonians","page":"Hamiltonians","title":"Rimu.Hamiltonians","text":"module Hamiltonians\n\nThis module defines Hamiltonian types, interfaces, and functions for working with Hamiltonians.\n\n\n\n\n\n","category":"module"},{"location":"hamiltonians.html#Relation-to-other-parts-of-the-Rimu-code","page":"Hamiltonians","title":"Relation to other parts of the Rimu code","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"In order to define a specific model Hamiltonian with relevant parameters for the model, instantiate the model like this in the input file:","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"ham = BoseHubbardReal1D(n=6, m=6, u=1.0, t=1.0, AT = BSAdd64)","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"In the rest of the Rimu code, access to properties and matrix elements of the model are then provided by the following methods:","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"ham[address1, address2]:  indexing of matrix elements (slow - use with caution)\nham(dv::AbstractDVec) or mul!(dv1, ham, dv2): use as linear operator\ndiagME(ham, add): diagonal matrix element\nnumOfHops(ham, add): number of off-diagonals\nhop(ham, add, chosen): access off-diagonal matrix element\nHops(ham, add): iterator over off-diagonal matrix elements\ngenerateRandHop(hops::Hops): choose random off-diagonal\nbit_String_Length(ham): number of bits in the configuration\nham(:dim) and ham(:fdim): dimension of linear space. See  hasIntDimension(ham), dimensionLO(ham), fDimensionLO(ham)\nnearUniform(ham): configuration with particles spread across modes","category":"page"},{"location":"hamiltonians.html#Model-Hamiltonians","page":"Hamiltonians","title":"Model Hamiltonians","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"Here is a list of fully implemented model Hamiltonians. So far there are two variants implemented of the one-dimentional Bose-Hubbard model real space as well as a momentum-space Hubbard chain.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"BoseHubbardReal1D\nExtendedBHReal1D\nBoseHubbardMom1D","category":"page"},{"location":"hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D","page":"Hamiltonians","title":"Rimu.Hamiltonians.BoseHubbardReal1D","text":"ham = BoseHubbardReal1D(;[n=6, m=6, u=1.0, t=1.0, AT = BSAdd64])\n\nImplements a one-dimensional Bose Hubbard chain in real space.\n\nhatH = -t sum_langle ijrangle a_i^ a_j + fracu2sum_i n_i (n_i-1)\n\nwarning: Warning\nThis Hamiltonian is deprecated. Please use HubbardReal1D instead.\n\nArguments\n\nn::Int: the number of bosons\nm::Int: the number of lattice sites\nu::Float64: the interaction parameter\nt::Float64: the hopping strength\nAT::Type: the address type\n\nFunctor use:\n\nw = ham(v)\nham(w, v)\n\nCompute the matrix - vector product w = ham * v. The two-argument version is mutating for w.\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Rimu.Hamiltonians.ExtendedBHReal1D","page":"Hamiltonians","title":"Rimu.Hamiltonians.ExtendedBHReal1D","text":"ham = ExtendedBHReal1D(n=6, m=6, u=1.0, v=1.0, t=1.0, AT=BSAdd64)\n\nImplements the extended Bose Hubbard model on a one-dimensional chain in real space.\n\nhatH = -t sum_langle ijrangle a_i^ a_j + fracu2sum_i n_i (n_i-1) + v sum_langle ijrangle n_i n_j\n\nArguments\n\nn::Int: number of bosons\nm::Int: number of lattice sites\nu::Float64: on-site interaction parameter\nv::Float64: the next-neighbor interaction\nt::Float64: the hopping strength\nAT::Type: address type for identifying configuration\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D","page":"Hamiltonians","title":"Rimu.Hamiltonians.BoseHubbardMom1D","text":"ham = BoseHubbardMom1D(;[n=6, m=6, u=1.0, t=1.0], add = add)\nham = BoseHubbardMom1D(add; u=1.0, t=1.0)\n\nImplements a one-dimensional Bose Hubbard chain in momentum space.\n\nhatH = sum_k ϵ_k n_k + fracuMsum_kpqr a^_r a^_q a_p a_k δ_r+qp+k\nϵ_k = -2t cos(k)\n\nwarning: Warning\nThis Hamiltonian is deprecated. Please use HubbardMom1D instead.\n\nArguments\n\nn::Int: the number of bosons\nm::Int: the number of lattice sites\nu::Float64: the interaction parameter\nt::Float64: the hopping strength\nAT::Type: the address type\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Hamiltonians-interface","page":"Hamiltonians","title":"Hamiltonians interface","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"Behind the implementation of a particular model is a more abstract interface for defining hamiltonians. If you want to define a new model you should make use of this interface. The most general form of a model Hamiltonian should subtype to AbstractHamiltonian and implement the relevant methods.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"AbstractHamiltonian\nHops\ngenerateRandHop","category":"page"},{"location":"hamiltonians.html#Rimu.Hamiltonians.AbstractHamiltonian","page":"Hamiltonians","title":"Rimu.Hamiltonians.AbstractHamiltonian","text":"AbstractHamiltonian{T}\n\nSupertype that provides an interface for linear operators over a linear space with scalar type T that are suitable for FCIQMC. Indexing is done with addresses (typically not integers) from an address space that may be large (and will not need to be completely generated).\n\nAbstractHamiltonian instances operate on vectors of type AbstractDVec from the module DictVectors and work well with addresses of type AbstractFockAddress from the module BitStringAddresses. The type works well with the external package KrylovKit.jl.\n\nMethods\n\nProvides:\n\noffdiagonals: iterator over reachable off-diagonal matrix elements\nrandom_offdiagonal: function to generate random off-diagonal matrix element\ndimension: get the dimension of the address space.\nH[address1, address2]: indexing with getindex() - mostly for testing purposes\n*(H, v): deterministic matrix-vector multiply.\nH(v): equivalent to H * v.\nmul!(w, H, v): mutating matrix-vector multiply.\ndot(x, H, v): compute x⋅(H*v) minimizing allocations.\n\nMethods that need to be implemented:\n\nnum_offdiagonals(::AbstractHamiltonian, address)\nget_offdiagonal(::AbstractHamiltonian, address, chosen::Integer)\ndiagonal_element(::AbstractHamiltonian, address)\nstarting_address(::AbstractHamiltonian)\n\nOptional methods to implement:\n\nHamiltonians.LOStructure(::Type{typeof(lo)})\ndimension(::Type{T}, ::AbstractHamiltonian)\noffdiagonals(::AbstractHamiltonian, ::AbstractFockAddress)\nmomentum(::AbstractHamiltonian)\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Core-functions","page":"Hamiltonians","title":"Core functions","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"The following functions are part of the core functionality of a Hamiltonian and need to be implemented efficiently and specifically for each model.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"numOfHops\nhop\ndiagME","category":"page"},{"location":"hamiltonians.html#BosonicHamiltonian","page":"Hamiltonians","title":"BosonicHamiltonian","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"For a many-body system consisting of spinless bosons, we already know more about the structure of the problem. BosonicHamiltonian is a pre-defined subtype of AbstractHamiltonian.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"BosonicHamiltonian\nhasIntDimension\ndimensionLO\nfDimensionLO\nbit_String_Length\nnearUniform","category":"page"},{"location":"hamiltonians.html#Rimu.BitStringAddresses.nearUniform","page":"Hamiltonians","title":"Rimu.BitStringAddresses.nearUniform","text":"nearUniform(BoseFS{N,M})\nnearUniform(BoseFS{N,M,S}) -> bfs::BoseFS{N,M,S}\n\nCreate bosonic Fock state with near uniform occupation number of M modes with a total of N particles. Specifying the bit address type S is optional.\n\nExamples\n\njulia> nearUniform(BoseFS{7,5,BitString{14}})\nBoseFS((2,2,1,1,1))\n\njulia> nearUniform(BoseFS{7,5})\nBoseFS((2,2,1,1,1))\n\n\n\n\n\n","category":"function"},{"location":"consistentrng.html#Random-Numbers","page":"Random Numbers","title":"Random Numbers","text":"","category":"section"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"Generating good quality random numbers is crucial for any Monte Carlo code. In addition to generating pseudo random numbers with good statistics and in minimal CPU time, we also have the requirement that computations should be reproducible and the random number sequences independent on each worker when the code runs in parallel mode.","category":"page"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"We define the random number generator in the module ConsistentRNG.jl, which is loaded onto each process. Furthermore, independent seeds are used to seed the RNGs on each worker (from goQMC.jl). These seeds are generated using the Random.RandomDevice random number generator, which draws entropy from the operating system / hardware. The seeds are saved to file with a filename that includes the number of processes used. If a suitable file is found, then seeds are read in from the file. This behaviour can be controlled by the flag reuseRandomSeeds in the input file.","category":"page"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"For the random number generator we are currently using 'Xoroshiro128Plus' from 'RandomNumbers.jl'. For benchmarks and statistical test results see the Documentation of RandomNumbers.jl.","category":"page"},{"location":"consistentrng.html#Module-ConsistentRNG.jl","page":"Random Numbers","title":"Module ConsistentRNG.jl","text":"","category":"section"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"Modules = [Rimu.ConsistentRNG]","category":"page"},{"location":"consistentrng.html#Rimu.ConsistentRNG","page":"Random Numbers","title":"Rimu.ConsistentRNG","text":"module ConsistentRNG\n\nProvides a an array random number generators with one for each thread.\n\nExports cRand() and seedCRNG!(). These are thread consistent.\n\n\n\n\n\n","category":"module"},{"location":"consistentrng.html#Rimu.ConsistentRNG.CRNGs","page":"Random Numbers","title":"Rimu.ConsistentRNG.CRNGs","text":"CRNGs[]\n\nDefines an array of random number generators suitable for threaded code. For MPI or distributed runs it should be seeded separately on each process with seedCRNG!. Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post. In order to change the random number generator, edit 'ConsistentRNG.jl'.\n\nrng = CRNGs[][Threads.threadid()]\nrand(rng)\n\n\n\n\n\n","category":"constant"},{"location":"consistentrng.html#Rimu.ConsistentRNG.CRNG","page":"Random Numbers","title":"Rimu.ConsistentRNG.CRNG","text":"Baseline random number generator used throughout. Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post. In order to change the random number generator, edit 'ConsistentRNG.jl'.\n\n\n\n\n\n","category":"type"},{"location":"consistentrng.html#Rimu.ConsistentRNG.cRand-Tuple","page":"Random Numbers","title":"Rimu.ConsistentRNG.cRand","text":"r = cRand(args...)\n\nSimilar to 'rand(args)' but uses consistent random number generator 'CRNGs[]'. 'cRand()' generates a single uniformly distributed random number in the interval [0,1). Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.cRandn-Tuple","page":"Random Numbers","title":"Rimu.ConsistentRNG.cRandn","text":"r = cRandn(args...)\n\nSimilar to 'randn(args)' but uses consistent random number generators 'CRNGs[]'. 'cRandn()' generates a single normally distributed random number. Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.check_crng_independence-Tuple{Any}","page":"Random Numbers","title":"Rimu.ConsistentRNG.check_crng_independence","text":"ConsistentRNG.check_crng_independence(v)\n\nPrimitve test to check the random number generators. It throws an error if some of the threaded random number generators are equal. Returns the number of threaded RNGs.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.newChildRNG","page":"Random Numbers","title":"Rimu.ConsistentRNG.newChildRNG","text":"newChildRNG(parent_rng = trng())\n\nRandom number generator that is seeded deterministically from the thread-consistent global rng trng(). By scrambling with hash(), a statistically independent pseudo-random sequence from the parent rng is accessed.\n\n\n\n\n\n","category":"function"},{"location":"consistentrng.html#Rimu.ConsistentRNG.seedCRNG!-Tuple{Vector{T} where T}","page":"Random Numbers","title":"Rimu.ConsistentRNG.seedCRNG!","text":"seedCRNG!([seed])\n\nSeed the threaded consistent random number generators CRNGs[]. If a single number is given, this will be used to seed a random sequence, which is hashed and then used to generate seeds for each rng in the vector CRNGs. When no argument is given, each rng is seeded randomly.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.sync_cRandn-Tuple{Any}","page":"Random Numbers","title":"Rimu.ConsistentRNG.sync_cRandn","text":"sync_cRandn(v)\n\nGenerate one random number with cRandn() in a synchronous way. Defaults to cRandn().\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.trng-Tuple{}","page":"Random Numbers","title":"Rimu.ConsistentRNG.trng","text":"trng()\n\nThread local random number generator.\n\nrand(trng())\nrand(trng(),UInt)\n\n\n\n\n\n","category":"method"},{"location":"testing.html#Code-testing","page":"Code testing","title":"Code testing","text":"","category":"section"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"The script runtest.jl in the test/ folder contains tests of the code. To run the test simply run the script from the Julia REPL or run","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"Rimu$ julia test/runtest.jl","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"from the command line.","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"More tests should be added over time to test core functionality of the code. To add new tests, directly edit the file runtest.jl.","category":"page"},{"location":"testing.html#Automated-testing-with-Pipelines","page":"Code testing","title":"Automated testing with Pipelines","text":"","category":"section"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"Bitbucket Pipelines are set up to run the test script automatically on the Bitbucket cloud server every time a new commit to the master branch is pushed to the server. The setup for this to happen is configured in the file bitbucket-pipelines.yml in the Rimu/ folder.","category":"page"},{"location":"testing.html#Modifying-the-Project.toml-file","page":"Code testing","title":"Modifying the Project.toml file","text":"","category":"section"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"In order for the testing code to be able to run on the cloud server, external packages that are accessed in the code with using or import need to be installed first. This is done in the script bitbucket-pipelines.yml via the package manager, based on the information contained in the file test/Project.toml. More packages can be added to this file using the package manager in the following way: Say we want to install the package DelimitedFiles. At the Julia REPL, type the following:","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"julia> cd(\"test\")\njulia> ]\n(v1.0) pkg> activate .\n(test) pkg> add DelimitedFiles","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"This will a new line to the file Project.toml with the name of the package and the corresponding uuid. When Pipelines now runs the commands in yml script, it will install the package DelimitedFiles before running the runtest.jl script.","category":"page"},{"location":"BHM-example.html#Example:-1D-Bose-Hubbard-Model","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"","category":"section"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"This is an example calculation finding the ground state of a 1D Bose-Hubbard chain with 6 particles in 6 lattice site. The Julia run-able script is in scripts/BHM-example.jl.","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Firstly, we load all needed modules. Rimu for FCIQMC calculation;","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"using Rimu","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now we define the physical problem: Setting the number of lattice sites m = 6; and the number of particles n = 6:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"m = n = 6","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Generating a configuration that particles are evenly distributed:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"aIni = nearUniform(BoseFS{n,m})","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"where BoseFS is used to create a bosonic system. The Hamiltonian is defined based on the configuration aIni, with additional onsite interaction strength u = 6.0 and the hopping strength t = 1.0:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Ĥ = HubbardReal1D(aIni; u = 6.0, t = 1.0)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now let's setup the Monte Carlo settings. The number of walkers to use in this Monte Carlo run:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"targetwalkers = 1_000","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"The number of time steps before doing statistics, i.e. letting the walkers to sample Hilbert and to equilibrate:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"steps_equilibrate = 1_000","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"And the number of time steps used for getting statistics, e.g. time-average of shift, projected energy, walker numbers, etc.:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"steps_measure = 1_000","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Set the size of a time step","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"dτ = 0.001","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"and we report QMC data every k-th step, setting k = 1 means we record QMC data every step:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"k = 1","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now we prepare initial state and allocate memory. The initial address is defined above as aIni = nearUniform(Ĥ). Define the initial number of walkers per rank:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"nIni = 1","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Putting the nIni number of walkers into the initial address aIni","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"svec = DVec(aIni => nIni)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Let's plant a seed for the random number generator to get consistent result:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Rimu.ConsistentRNG.seedCRNG!(17)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now let's setup all the FCIQMC strategies.","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Passing dτ and total number of time steps into params:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"params = RunTillLastStep(dτ = dτ, laststep = steps_equilibrate + steps_measure)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Strategy for updating the shift:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"s_strat = DoubleLogUpdate(targetwalkers = targetwalkers, ζ = 0.08)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Strategy for reporting info and setting projectors:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"r_strat = ReportDFAndInfo(k = k, i = 100, projector = copy(svec))","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Strategy for updating dτ:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"t_strat = ConstantTimeStep()","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Print out info about what we are doing:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"println(\"Finding ground state for:\")\nprintln(Ĥ)\nprintln(\"Strategies for run:\")\nprintln(params, s_strat)\nprintln(t_strat)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Finally, we can start the main FCIQMC loop:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"df, state = lomc!(Ĥ,svec;\n            params = params,\n            laststep = steps_equilibrate + steps_measure,\n            s_strat = s_strat,\n            r_strat = r_strat,\n            τ_strat = t_strat);\nprintln(\"Writing data to disk...\")","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Saving output data stored in df into a .arrow file which can be read in later:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"save_df(\"fciqmcdata.arrow\", df)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now let's look at the calculated energy from the shift: Loading the equilibrated data:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"qmcdata = last(df,steps_measure)\nusing Rimu.StatsTools","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"For the shift, it's easy to use mean_and_se from Rimu.StatsTools","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"(qmcShift,qmcShiftErr) = mean_and_se(qmcdata.shift)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"For the projected energy, it a bit more complicated as it's a ratio of two means:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"r = ratio_of_means(qmcdata.hproj,qmcdata.vproj)\nrwe = ratio_with_errs(r)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Here we use the 95% CI for the lower and upper error bars:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"(eProj,eProjErrLower,eProjErrUpper) = (rwe.ratio, rwe.err2_l, rwe.err2_u)\n\nprintln(\"Energy from $steps_measure steps with $targetwalkers walkers:\n         Shift: $qmcShift ± $qmcShiftErr;\n         Projected Energy: $eProj ± ($eProjErrLower, $eProjErrUpper)\")","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Finished !","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"println(\"Finished!\")","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"documentation.html#Documentation-generation","page":"Documentation generation","title":"Documentation generation","text":"","category":"section"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"We are using Documenter.jl to generate the documentation web site based on markdown files stored in docs/src. Please help keeping the documentation up-to-date by editing the markdown files! For instructions on how to write appropriate documentation please refer to the relevant chapter in the Julia documentation and the Documenter.jl documentation.","category":"page"},{"location":"documentation.html#Generating-the-documentation-web-site","page":"Documentation generation","title":"Generating the documentation web site","text":"","category":"section"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"The documentation pages can be generated by running the build script by typing","category":"page"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"Rimu$ julia docs/build.jl","category":"page"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"on the shell prompt from the Rimu/ folder. A complete image of the static documentation web site will be generated in the folder docs/build/. It can be viewed locally by pointing a web browser to file docs/build/index.html, or by deploying it to the Bitbucket pages web server.","category":"page"},{"location":"documentation.html#Automatic-documentation-generation-and-deployment","page":"Documentation generation","title":"Automatic documentation generation and deployment","text":"","category":"section"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"Our documentation is hosted on a Bitbucket pages web site. The documentation web site can be built and deployed automatically with BitBucket pipelines. This needs to be set up with an appropriate script in the file bitbucket-pipelines.yml in the project folder, where triggers for this to happen can be defined. In the current set up, a new documentation web site is generated and deployed whenever someone pushes to the master branch on the BitBucket server. The updated documentation can then be accessed at https://joachimbrand.bitbucket.io/Rimu.jl/dev/.","category":"page"},{"location":"API.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"API.html#Rimu","page":"API","title":"Rimu","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [Rimu]","category":"page"},{"location":"API.html#Rimu.Rimu","page":"API","title":"Rimu.Rimu","text":"Rimu\n\nRandom Integrator for Many-Body Quantum Systems\n\n\n\n\n\n","category":"module"},{"location":"API.html#Rimu.AllOverlaps","page":"API","title":"Rimu.AllOverlaps","text":"AllOverlaps(n=2, operator=nothing) <: ReplicaStrategy{n}\n\nRun n replicas and report overlaps between all pairs of replica vectors. If operator is not nothing, the overlap dot(c1, operator, c2) is reported as well. If operator is a tuple of operators, the overlaps are computed for all operators.\n\nColumn names in the report are of the form c{i}dotc{j} for vector-vector overlaps, and c{i}Op{k}c{j} for operator overlaps.\n\nSee ReplicaStrategy and AbstractHamiltonian (for an interface for implementing operators).\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ConstantTimeStep","page":"API","title":"Rimu.ConstantTimeStep","text":"Keep dτ constant.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedDoubleLogUpdate","page":"API","title":"Rimu.DelayedDoubleLogUpdate","text":"DelayedDoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, A=10) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ and delay of A steps. See DoubleLogUpdate.\n\nS^n+A = S^n -fracζA dτlnleft(fracΨ_1^n+AΨ_1^nright)-fracξA dτlnleft(fracΨ_1^n+AΨ_1^texttargetright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedDoubleLogUpdateAfterTW","page":"API","title":"Rimu.DelayedDoubleLogUpdateAfterTW","text":"DelayedDoubleLogUpdateAfterTW(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, A=10) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ and delay of A steps after the number of target walkers is reached. See DoubleLogUpdate.\n\nS^n+A = S^n -fracζA dτlnleft(fracΨ_1^n+AΨ_1^nright)-fracξA dτlnleft(fracΨ_1^n+AΨ_1^texttargetright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedLogUpdate","page":"API","title":"Rimu.DelayedLogUpdate","text":"DelayedLogUpdate(ζ = 0.08, a = 10) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and delay of a steps.\n\nS^n+a = S^n -fracζa dτlnleft(fracΨ_1^n+aΨ_1^nright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedLogUpdateAfterTargetWalkers","page":"API","title":"Rimu.DelayedLogUpdateAfterTargetWalkers","text":"DelayedLogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, a = 10) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ and delay of a steps. See DelayedLogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DeltaMemory","page":"API","title":"Rimu.DeltaMemory","text":"DeltaMemory(Δ::Int) <: MemoryStrategy\n\nBefore updating the shift, memory noise with a memory length of Δ is applied, where Δ = 1 means no memory noise.\n\nr̃ = (pnorm - tnorm)/(dτ*pnorm) + shift\nr = r̃ - <r̃>\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DeltaMemory2","page":"API","title":"Rimu.DeltaMemory2","text":"DeltaMemory2(Δ::Int) <: MemoryStrategy\n\nBefore updating the shift, memory noise with a memory length of Δ is applied, where Δ = 1 means no memory noise.\n\nr̃ = pnorm - tnorm + shift*dτ*pnorm\nr = (r̃ - <r̃>)/(dτ*pnorm)\n\nThe long-term average of r is not guaranteed to be zero.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DeltaMemory3","page":"API","title":"Rimu.DeltaMemory3","text":"DeltaMemory3(Δ::Int, level::Float64) <: MemoryStrategy\n\nBefore updating the shift, apply multiplicative memory noise with a memory length of Δ at level level, where Δ = 1 means no memory noise.\n\nr̃ = (pnorm - tnorm)/pnorm + dτ*shift\nr = r̃ - <r̃>\nw .*= 1 + level*r\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DontUpdate","page":"API","title":"Rimu.DontUpdate","text":"DontUpdate() <: ShiftStrategy Don't update the shift.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogProjected","page":"API","title":"Rimu.DoubleLogProjected","text":"DoubleLogProjected(; target, projector, ζ = 0.08, ξ = ζ^2/4) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ after projecting onto projector.\n\nS^n+1 = S^n -fracζdτlnleft(fracPΨ^(n+1)PΨ^(n)right)-fracξdτlnleft(fracPΨ^(n+1)texttargetright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogSumUpdate","page":"API","title":"Rimu.DoubleLogSumUpdate","text":"DoubleLogSumUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, α = 1/2) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameters ζ and ξ.\n\nS^n+1 = S^n -fracζdτlnleft(fracN_mathrmw^n+1N_mathrmw^nright)\n- fracξdτlnleft(fracN_mathrmw^n+1N_mathrmw^texttargetright)\n\nwhere N_mathrmw = (1-α)*walkernumber() + α*UniformProjector()⋅ψ computed with walkernumber() and UniformProjector(). When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogUpdate","page":"API","title":"Rimu.DoubleLogUpdate","text":"DoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ.\n\nS^n+1 = S^n -fracζdτlnleft(fracΨ_1^n+1Ψ_1^nright)-fracξdτlnleft(fracΨ_1^n+1Ψ_1^texttargetright)\n\nWhen ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogUpdateAfterTargetWalkers","page":"API","title":"Rimu.DoubleLogUpdateAfterTargetWalkers","text":"LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, ξ = 0.0016) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ and ξ. See DoubleLogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogUpdateAfterTargetWalkersSwitch","page":"API","title":"Rimu.DoubleLogUpdateAfterTargetWalkersSwitch","text":"LogUpdateAfterTargetWalkersSwitch(targetwalkers, ζ = 0.08, ξ = 0.0016) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ and ξ. After a steps the strategy switches to LogUpdate. See DoubleLogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.EveryKthStep","page":"API","title":"Rimu.EveryKthStep","text":"EveryKthStep(;k = 10, projector = nothing, hproj = :auto)\n\nReport every kth step. Include projection onto projector. See ReportingStrategy for details.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.EveryTimeStep","page":"API","title":"Rimu.EveryTimeStep","text":"EveryTimeStep(;projector = nothing, hproj = :auto)\n\nReport every time step. Include projection onto projector. See ReportingStrategy for details.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.FciqmcRunStrategy","page":"API","title":"Rimu.FciqmcRunStrategy","text":" FciqmcRunStrategy{T}\n\nAbstract type representing the strategy for running and terminating fciqmc!(). The type parameter T is relevant for reporting the shift and the norm.\n\nImplemented strategies:\n\nRunTillLastStep\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.HistoryLogUpdate","page":"API","title":"Rimu.HistoryLogUpdate","text":"HistoryLogUpdate(df::DataFrame; d = 100, k=1, ζ= 0.08)\n\nStrategy for updating the shift according to log formula but with walker numbers accumulated from k samples of the history with delay d. A recent history has to be passed with the data frame df for initialisation.\n\nN_w^n = sum_i=0^k-1 Ψ_1^n-i \nS^n+a = S^n -fracζa dτlnleft(fracN_w^n+1N_w^nright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.LogUpdate","page":"API","title":"Rimu.LogUpdate","text":"LogUpdate(ζ = 0.08) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ.\n\nS^n+1 = S^n -fracζdτlnleft(fracΨ_1^n+1Ψ_1^nright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.LogUpdateAfterTargetWalkers","page":"API","title":"Rimu.LogUpdateAfterTargetWalkers","text":"LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ. See LogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.MemoryStrategy","page":"API","title":"Rimu.MemoryStrategy","text":"Abstract type for defining the strategy for injectimg memory noise. Implemented strategies:\n\nNoMemory\nDeltaMemory\nShiftMemory\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.NoMemory","page":"API","title":"Rimu.NoMemory","text":"NoMemory <: MemoryStrategy\n\nDefault strategy for MemoryStrategy indicating that no memory noise will be used.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.NoStats","page":"API","title":"Rimu.NoStats","text":"NoStats(N=1) <: ReplicaStrategy{N}\n\nThe default ReplicaStrategy. N replicas are run, but no statistics are collected.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ProjectedMemory","page":"API","title":"Rimu.ProjectedMemory","text":"ProjectedMemory(Δ::Int, projector, pp::Number) <: MemoryStrategy\nProjectedMemory(Δ::Int, projector, v::AbstractDVec)\n\nBefore updating the shift, apply memory noise to minimize the fluctuations of the overlap of the coefficient vector with projector. Averaging over Δ time steps is applied, where Δ = 1 means no memory noise is applied. Use pp to initialise the value of the projection or pass v in order to initialise the projection with pp = projector.v.\n\nr̃ = (projector⋅v - projector⋅w)/projector⋅v + dτ*shift\nr = r̃ - <r̃>\n\nwhere v is the coefficient vector before and w after applying a regular FCIQMC step.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.PurgeNegatives","page":"API","title":"Rimu.PurgeNegatives","text":"PurgeNegatives <: MemoryStrategy\n\nPurge all negative sign walkers.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.QMCState","page":"API","title":"Rimu.QMCState","text":"QMCState\n\nHolds all inforamtion needed to run FCIQMC, except the data frame. Holds a NTuple of ReplicaStates and various strategies that control the algorithm.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ReplicaState","page":"API","title":"Rimu.ReplicaState","text":"ReplicaState(hamiltonian, v, w, pnorm, r_strat)\n\nStruct that holds all information needed for an independent run of the algorithm.\n\nCan be advanced a step forward with advance!.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ReplicaStrategy","page":"API","title":"Rimu.ReplicaStrategy","text":"ReplicaStrategy{N}\n\nAn abstract type that controles how lomc! uses replicas. A subtype of ReplicaStrategy{N} operates on N replicas and must implement the following function:\n\nreplica_stats(::ReplicaStrategy{N}, ::NTuple{N,ReplicaState}) - return a tuple of Strings or Symbols of replica statistic names and a tuple of the values.  These will be reported to the DataFrame returned by lomc!\n\nConcrete implementations:\n\nNoStats: run (possibly one) replica(s), but don't report any additional info.\nAllOverlaps: report overlaps between all pairs of replica vectors.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.Report","page":"API","title":"Rimu.Report","text":"Report\n\nInternal structure that hold the temporary reported values. See report!.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ReportDFAndInfo","page":"API","title":"Rimu.ReportDFAndInfo","text":"ReportDFAndInfo(; k=10, i=100, io=stdout, writeinfo=true, projector = nothing, hproj = :auto)\n\nReport every kth step in DataFrame and write info message to io every ith step (unless writeinfo == false). The flag writeinfo is useful for controlling info messages in MPI codes. Include projection onto projector. See ReportingStrategy for details.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ReportingStrategy","page":"API","title":"Rimu.ReportingStrategy","text":"ReportingStrategy\n\nAbstract type for strategies for reporting data in a DataFrame with report!(). It also affects the calculation and reporting of projected quantities in the DataFrame.\n\nImplemented strategies:\n\nEveryTimeStep\nEveryKthStep\nReportDFAndInfo\n\nEvery strategy accepts the keyword arguments projector and hproj according to which a projection of the instantaneous coefficient vector projector⋅v and hproj⋅v are reported to the DataFrame in the fields df.vproj and df.hproj, respectively. Possible values for projector are\n\nnothing - no projections are computed (default)\ndv::AbstractDVec - compute projection onto coefficient vector dv (set up with copy to conserve memory)\nUniformProjector() - projection onto vector of all ones (i.e. sum of elements)\nNormProjector() - compute 1-norm (instead of projection)\nNorm1ProjectorPPop() - compute 1-norm per population\nNorm2Projector() - compute 2-norm\n\nIn order to help set up the calculation of the projected energy, where df.hproj should report dot(projector, ham, v), the keyword hproj accepts the following values (for ReportingStrategys passed to lomc!()):\n\n:auto - choose method depending on projector and ham (default)\n:lazy - compute dot(projector, ham, v) every time (slow)\n:eager -  precompute hproj as ham'*v (fast, requires adjoint(ham))\n:not - don't compute second projector (equivalent to nothing)\n\nInterface\n\nA ReportingStrategy must define the following:\n\nreport!\nprint_report (optional)\n\nExamples\n\nr_strat = EveryTimeStep(projector = copy(svec))\n\nRecord the projected energy components df.vproj = svec⋅v and df.hproj = dot(svec,ham,v) with respect to the starting vector (performs fast eager calculation if Hamiltonians.LOStructure(ham) ≠ Hamiltonians.AdjointUnknown()), and report every time step.\n\nr_strat = EveryKthStep(k=10, projector = UniformProjector(), hproj = :lazy)\n\nRecord the projection of the instananeous coefficient vector v onto the uniform vector of all 1s into df.vproj and of ham⋅v into df.hproj, and report every kth time step.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.RunTillLastStep","page":"API","title":"Rimu.RunTillLastStep","text":"RunTillLastStep(step::Int = 0 # number of current/starting timestep\n             laststep::Int = 100 # number of final timestep\n             shiftMode::Bool = false # whether to adjust shift\n             shift = 0.0 # starting/current value of shift\n             dτ::Float64 = 0.01 # current value of time step\n) <: FciqmcRunStrategy\n\nParameters for running fciqmc!() for a fixed number of time steps. For alternative strategies, see FciqmcRunStrategy.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ShiftMemory","page":"API","title":"Rimu.ShiftMemory","text":"ShiftMemory(Δ::Int) <: MemoryStrategy\n\nEffectively replaces the fluctuating shift update procedure for the coefficient vector by an averaged shift over Δ timesteps, where Δ = 1 means no averaging.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ShiftStrategy","page":"API","title":"Rimu.ShiftStrategy","text":"Abstract type for defining the strategy for updating the shift with update_shift(). Implemented strategies:\n\nDoubleLogUpdate - default in lomc!()\nDontUpdate\nLogUpdate\nDelayedLogUpdate\nLogUpdateAfterTargetWalkers - FCIQMC standard\nDelayedLogUpdateAfterTargetWalkers\nDoubleLogUpdateAfterTargetWalkers\nDoubleLogUpdateAfterTargetWalkersSwitch\nHistoryLogUpdate\nDoubleLogProjected\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.TimeStepStrategy","page":"API","title":"Rimu.TimeStepStrategy","text":"Abstract type for strategies for updating the time step with update_dτ(). Implemented strategies:\n\nConstantTimeStep\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.TripleLogUpdate","page":"API","title":"Rimu.TripleLogUpdate","text":"TripleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, η = 0.01) <: ShiftStrategy\n\nStrategy for updating the shift according to the extended log formula with damping parameters ζ, ξ, and η.\n\nS^n+1 = S^n -fracζdτlnleft(fracN_mathrmw^n+1N_mathrmw^nright)\n- fracξdτlnleft(fracN_mathrmw^n+1N_mathrmw^texttargetright)\n- fracηdτlnleft(fracℜ(Ψ^n+1)_1^2 + ℑ(Ψ^n+1)_1^2\nℜ(Ψ^n)_1^2 + ℑ(Ψ^n)_1^2right)\n\nwhere N_mathrmw is the walkernumber(). When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, V, W, R} where {V, W, R<:FciqmcRunStrategy{T}}}} where T","page":"API","title":"Rimu.advance!","text":"advance!(report::Report, state::QMCState, replica::ReplicaState)\n\nAdvance the replica by one step. The state is used only to access the various strategies involved. Steps, stats, and computed quantities are written to the report.\n\nReturns true if the step was successful.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T<:Real}","page":"API","title":"Rimu.apply_memory_noise!","text":"r = apply_memory_noise!(w, v, shift, dτ, pnorm, m_strat::MemoryStrategy)\n\nApply memory noise to w, i.e. w .+= r.*v, computing the noise r according to m_strat. Note that m_strat needs to be compatible with StochasticStyle(w). Otherwise, an error exception is thrown. See MemoryStrategy.\n\nw is the walker array after fciqmc step, v the previous one, pnorm the norm of v, and r the instantaneously applied noise.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.compute_proj_observables-Tuple{Any, Any, ReportingStrategy{Nothing, Nothing}}","page":"API","title":"Rimu.compute_proj_observables","text":"compute_proj_observables(v, ham, r::ReportingStrategy)\n\nCompute the projection of r.projector⋅v and r.hproj⋅v or r.projector⋅ham*v according to the ReportingStrategy r.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T<:Real}","page":"API","title":"Rimu.fciqmc_col!","text":"fciqmc_col!(w, ham, add, num, shift, dτ)\nfciqmc_col!(::Type{T}, args...)\n-> spawns, deaths, clones, antiparticles, annihilations\n\nSpawning and diagonal step of FCIQMC for single column of ham. In essence it computes\n\nw .+= (1 .+ dτ.*(shift .- ham[:,add])).*num.\n\nDepending on T ==StochasticStyle(w), a stochastic or deterministic algorithm will be chosen. The possible values for T are:\n\nIsDeterministic() deteministic algorithm\nIsStochasticInteger() stochastic version where the changes added to w are purely integer, according to the FCIQMC algorithm\nIsStochasticWithThreshold(c) stochastic algorithm with floating point walkers.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.fciqmc_step!","page":"API","title":"Rimu.fciqmc_step!","text":"fciqmc_step!(Ĥ, v, shift, dτ, pnorm, w;\n                      m_strat::MemoryStrategy = NoMemory()) -> ṽ, w̃, stats\n\nPerform a single matrix(/operator)-vector multiplication:\n\ntildev = 1 - dτ(hatH - S)v \n\nwhere Ĥ == ham and S == shift. Whether the operation is performed in stochastic, semistochastic, or determistic way is controlled by the trait StochasticStyle(w). See StochasticStyle. w is a local data structure with the same size and type as v and used for working. Both v and w are modified.\n\nReturns the result ṽ, a (possibly changed) reference to working memory w̃,  and the array stats = [spawns, deaths, clones, antiparticles, annihilations]. Stats will contain zeros when running in deterministic mode.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Rimu.lomc!-Tuple{Any, Any}","page":"API","title":"Rimu.lomc!","text":"lomc!(ham, v; kwargs...)\n\nLinear operator Monte Carlo: Perform the FCIQMC algorithm for determining the lowest eigenvalue of ham. v can be a single starting vector of (wrapped) type :<AbstractDVec.\n\nReturns a DataFrame with various statistics and a QMCState containing all information required for continuation runs.\n\nKeyword arguments, defaults, and precedence:\n\nlaststep - can be used to override information otherwise contained in params\nthreading = :auto - can be used to control the use of multithreading (overridden by wm)\n:auto - use multithreading if s_strat.targetwalkers ≥ 500\ntrue - use multithreading if available (set shell variable JULIA_NUM_THREADS!)\nfalse - run on single thread\nwm - working memory; if set, it controls the use of multithreading and overrides threading; is mutated\nparams::FciqmcRunStrategy = RunTillLastStep(laststep = 100) - contains basic parameters of simulation state, see FciqmcRunStrategy; is mutated\ns_strat::ShiftStrategy = DoubleLogUpdate(targetwalkers = 1000) - see ShiftStrategy\nr_strat::ReportingStrategy = EveryTimeStep() - see ReportingStrategy\nτ_strat::TimeStepStrategy = ConstantTimeStep() - see TimeStepStrategy\nm_strat::MemoryStrategy = NoMemory() - see MemoryStrategy\nreplica::ReplicaStrategy = NoStats(1) - see ReplicaStrategy.\n\nReturn values\n\nlomc! returns a named tuple with the following fields:\n\ndf: a DataFrame with all statistics being reported.\nstate: a QMCState that can be used for continuations.\n\nExample\n\njulia> add = BoseFS((1,2,3));\n\njulia> H = HubbardReal1D(add);\n\njulia> dv = DVec(add => 1);\n\njulia> df1, state = lomc!(H, dv);\n\njulia> df2, _ = lomc!(state, df1; laststep=200); # Contuniation run\n\njulia> size(df1)\n(100, 12)\n\njulia> size(df2)\n(200, 12)\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.print_report-Tuple{ReportingStrategy, Vararg{Any, N} where N}","page":"API","title":"Rimu.print_report","text":"print_report(::ReportingStrategy, step, report, state)\n\nThis function is called at the very end of a step. It can let the ReportingStrategy print some information to output.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.refine_r_strat-Tuple{ReportingStrategy, Any}","page":"API","title":"Rimu.refine_r_strat","text":"Rimu.refine_r_strat(r_strat::ReportingStrategy, ham)\n\nRefine the reporting strategy by replacing Symbols in the keyword argument hproj by the appropriate value. See ReportingStrategy\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.replica_stats","page":"API","title":"Rimu.replica_stats","text":"replica_stats(::ReplicaStrategy{N}, replicas::NTuple{N,ReplicaState}) -> (names, values)\n\nReturn the names and values of statistics reported by ReplicaStrategy. names should be a tuple of Symbols or Strings and values should be a tuple of the same length.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Rimu.report!-Tuple{Any, Any, Any}","page":"API","title":"Rimu.report!","text":"report!(report, keys, values, id=\"\")\nreport!(report, nt, id=\"\")\n\nWrite keys, values pairs to report that will be converted to a DataFrame later. Alternatively, a named tuple can be passed instead of keys and values.\n\nThe value of id is appended to the name of the column, e.g. report!(report, :key, value, :_1) will report value to a column named :key_1.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.report!-Tuple{EveryTimeStep, Any, Vararg{Any, N} where N}","page":"API","title":"Rimu.report!","text":" report!(::ReportingStrategy, step, report::Report, keys, values, id=\"\")\n report!(::ReportingStrategy, step, report::Report, nt, id=\"\")\n\nReport keys and values to report, which will be converted to a DataFrame before lomc! exits. Alternatively, a nt::NamedTuple can be passed in place of keys and values. If id is specified, it is appended to all keys. This is used to differentiate between values reported by different replicas.\n\nTo overload this function for a new ReportingStrategy, overload report!(::ReportingStrategy, step, args...) and apply the report by calling report!(args...).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.sort_into_targets!-Tuple{Any, Any, Any}","page":"API","title":"Rimu.sort_into_targets!","text":"sort_into_targets!(target, source, stats) -> agg, wm, agg_stats\n\nAggregate coefficients from source to agg and from stats to agg_stats according to thread- or MPI-level parallelism. wm passes back a reference to working memory.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.step_stats-Tuple{StochasticStyle}","page":"API","title":"Rimu.step_stats","text":"step_stats(::StochasticStyle)\n\nReturn a tuple of names (Symbol or String) and a zeros of values of the same length. These will be reported as columns in the DataFrame returned by lomc!.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.threshold_projected_deposit!-Tuple{IsDynamicSemistochastic{var\"#s249\", false} where var\"#s249\", Any, Any, Any, Any}","page":"API","title":"Rimu.threshold_projected_deposit!","text":"threshold_projected_deposit!\n\nThis function performs threshold projection before spawning, but only for IsDynamicSemistochastic with the project_later parameter set to false.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.update_dvec!-Tuple{StochasticStyle, Any}","page":"API","title":"Rimu.update_dvec!","text":"update_dvec!([::StochasticStyle,] dvec) -> dvec, nt\n\nPerform an arbitrary transformation on dvec after the spawning step is completed and report statistics to the DataFrame.\n\nReturns the new dvec and a NamedTuple nt of statistics to be reported.\n\nWhen extending this function for a custom StochasticStyle, define a method  for the two-argument call signature!\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}","page":"API","title":"Rimu.update_dτ","text":"update_dτ(s<:TimeStepStrategy, dτ, args...) -> new dτ\n\nUpdate the time step according to the strategy s.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.update_shift-Tuple{HistoryLogUpdate, Any, Any, Any, Any, Any, Any, Any, Vararg{Any, N} where N}","page":"API","title":"Rimu.update_shift","text":"update_shift(s <: ShiftStrategy, shift, shiftMode, tnorm, pnorm, dτ, step, df, v_new, v_old)\n\nUpdate the shift according to strategy s. See ShiftStrategy.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Reexported-Submodules","page":"API","title":"Reexported Submodules","text":"","category":"section"},{"location":"API.html#Hamiltonians","page":"API","title":"Hamiltonians","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Link to Module Hamiltionians.jl","category":"page"},{"location":"API.html#BitStringAddresses","page":"API","title":"BitStringAddresses","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [BitStringAddresses]","category":"page"},{"location":"API.html#Rimu.BitStringAddresses.AbstractFockAddress","page":"API","title":"Rimu.BitStringAddresses.AbstractFockAddress","text":"AbstractFockAddress\n\nSupertype representing a Fock state.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.BitString","page":"API","title":"Rimu.BitStringAddresses.BitString","text":"BitString{B,N} <: AbstractBitString\n\nType for storing bitstrings of static size. Holds B bits in N chunks, where each chunk is an UInt64\n\nN is chosen automatically to accommodate B bits as efficiently as possible.\n\nConstructors\n\nBitString{B,N}(::SVector{N,T}): unsafe constructor. Does not check for ghost bits.\nBitString{B,N}(i::UInt64): as above, but sets i as the rightmost chunk.\nBitString{B}(::Integer): Convert integer to BitString. Integer is truncated to the correct number of bits.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.BoseFS","page":"API","title":"Rimu.BitStringAddresses.BoseFS","text":"BoseFS{N,M,S} <: AbstractFockAddress\nBoseFS(bs::S) where S <: BitAdd\nBoseFS(bs::S, b)\n\nAddress type that represents a Fock state of N spinless bosons in M orbitals by wrapping a bitstring of type S. Orbitals are stored in reverse order, i.e. the first orbital in a BoseFS is stored rightmost in the bitstring bs. If the number of significant bits b is not encoded in S it must be passed as an argument (e.g. for BSAdd64 and BSAdd128).\n\nConstructors\n\nBoseFS{N,M}(::BitString): Unsafe constructor. Does not check whether the number of ones in a is equal to N.\nBoseFS(::BitString): Automatically determine N and M. This constructor is not type stable!\nBoseFS{[N,M,S]}(onr): Create BoseFS{N,M} from onr representation. This is efficient as long as at least N is provided.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.BoseFS2C","page":"API","title":"Rimu.BitStringAddresses.BoseFS2C","text":"BoseFS2C{NA,NB,M,AA,AB} <: AbstractFockAddress\n\nAddress type that constructed with two BoseFS{N,M,S}. It represents a Fock state with two components, e.g. two different species of bosons with particle number NA from species S and particle number NB from species B. The number of orbitals M is expected to be the same for both components.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.OccupiedOrbitalIterator","page":"API","title":"Rimu.BitStringAddresses.OccupiedOrbitalIterator","text":"occupied_orbitals(b)\n\nIterate over occupied orbitals in BoseFS address. Returns tuples of (boson_number, orbital_number, bit_offset).\n\nNote that the bit_offset is zero-based!\n\nExample\n\n```jldoctest julia> b = BoseFS((1,5,0,4)) julia> for (n, i) in occupied_orbitals(b)     @show n, i end (n, i) = (1, 1) (n, i) = (5, 2) (n, i) = (4, 4)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.check_bitstring_typeparams-Union{Tuple{N}, Tuple{B}, Tuple{Val{B}, Val{N}}} where {B, N}","page":"API","title":"Rimu.BitStringAddresses.check_bitstring_typeparams","text":"check_bitstring_typeparams(::Val{B}, ::Val{N})\n\nCheck if number of bits B is consistent with number of chunks N. Throw an error if not.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.chunk_bits-Tuple{Any, Any}","page":"API","title":"Rimu.BitStringAddresses.chunk_bits","text":"chunks_bits(s, i)\n\nNumber of bits in the i-th chunk of s.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.chunks-Tuple{BitString}","page":"API","title":"Rimu.BitStringAddresses.chunks","text":"chunks(::Type{<:BitString})\nchunks(s)\n\nSVector that stores the chunks of s.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.has_ghost_bits-Tuple{S} where S<:BitString","page":"API","title":"Rimu.BitStringAddresses.has_ghost_bits","text":"has_ghost_bits(s)\n\nCheck for bits outside data field.\n\nSee also: remove_ghost_bits.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.m_onr-Tuple{BoseFS}","page":"API","title":"Rimu.BitStringAddresses.m_onr","text":"m_onr(bs)\n\nCompute and return the occupation number representation of the bit string address bs as an MVector{M,Int32}, where M is the number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{var\"#s12\"} where var\"#s12\"<:(BoseFS{N, M, S} where S<:BitString)}, Tuple{M}, Tuple{N}} where {N, M}","page":"API","title":"Rimu.BitStringAddresses.nearUniform","text":"nearUniform(BoseFS{N,M})\nnearUniform(BoseFS{N,M,S}) -> bfs::BoseFS{N,M,S}\n\nCreate bosonic Fock state with near uniform occupation number of M modes with a total of N particles. Specifying the bit address type S is optional.\n\nExamples\n\njulia> nearUniform(BoseFS{7,5,BitString{14}})\nBoseFS((2,2,1,1,1))\n\njulia> nearUniform(BoseFS{7,5})\nBoseFS((2,2,1,1,1))\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.nearUniformONR-Tuple{Number, Number}","page":"API","title":"Rimu.BitStringAddresses.nearUniformONR","text":"nearUniformONR(N, M) -> onr::SVector{M,Int}\n\nCreate occupation number representation onr distributing N particles in M modes in a close-to-uniform fashion with each orbital filled with at least N ÷ M particles and at most with N ÷ M + 1 particles.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_bits-Union{Tuple{Type{var\"#s12\"} where var\"#s12\"<:(BitString{B, N} where N)}, Tuple{B}} where B","page":"API","title":"Rimu.BitStringAddresses.num_bits","text":"num_bits(::Type{<:BitString})\nnum_bits(s::BitString)\n\nTotal number of bits stored in bitstring.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Type{var\"#s11\"} where var\"#s11\"<:(BitString{var\"#s6\", N} where var\"#s6\")}, Tuple{N}} where N","page":"API","title":"Rimu.BitStringAddresses.num_chunks","text":"num_chunks(::Type{<:BitString})\nnum_chunks(s::BitString)\n\nNumber of chunks in bitstring. Equivalent to length(chunks(s)).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Val{B}}, Tuple{B}} where B","page":"API","title":"Rimu.BitStringAddresses.num_chunks","text":"num_chunks(::Val{B})\n\nDetermine the number of chunks needed to store B bits.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_modes-Tuple{AbstractFockAddress}","page":"API","title":"Rimu.BitStringAddresses.num_modes","text":"num_modes(::Type{<:AbstractFockAddress})\n\nNumber of modes represented by address.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_particles-Tuple{AbstractFockAddress}","page":"API","title":"Rimu.BitStringAddresses.num_particles","text":"num_particles(::Type{<:AbstractFockAddress})\n\nNumber of particles represented by address.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.onr-Tuple{BoseFS}","page":"API","title":"Rimu.BitStringAddresses.onr","text":"onr(bs)\n\nCompute and return the occupation number representation of the bit string address bs as an SVector{M,Int32}, where M is the number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.remove_ghost_bits-Tuple{S} where S<:BitString","page":"API","title":"Rimu.BitStringAddresses.remove_ghost_bits","text":"remove_ghost_bits(s)\n\nRemove set bits outside data field if any are present.\n\nSee also: has_ghost_bits.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.top_chunk_bits-Union{Tuple{Type{var\"#s12\"} where var\"#s12\"<:(BitString{B, N} where N)}, Tuple{B}} where B","page":"API","title":"Rimu.BitStringAddresses.top_chunk_bits","text":"top_chunk_bits(::Type{<:BitString})\ntop_chunk_bits(s::BitString)\n\nNumber of bits stored in top chunk. Equivalent to chunk_bits(s, 1).\n\n\n\n\n\n","category":"method"},{"location":"API.html#DictVectors","page":"API","title":"DictVectors","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [DictVectors]","category":"page"},{"location":"API.html#Rimu.DictVectors","page":"API","title":"Rimu.DictVectors","text":"Module that provides data structures that behave similar to sparse vectors, but are indexed by arbitrary types (could be non-integers) similarly to dictionaries. The idea is to do linear algebra with data structures that are neither subtyped to AbstractVector nor to AbstractDict and are suitable for use with KrylovKit.jl. For this, the abstract type and interface AbstractDVec is provided, with the concrete implementation of DVec\n\n\n\n\n\n","category":"module"},{"location":"API.html#Rimu.DictVectors.AbstractDVec","page":"API","title":"Rimu.DictVectors.AbstractDVec","text":"DictVectors.AbstractDVec{K,V}\n\nAbstract type for sparse vectors with valtype V based on dictionary-like structures. The vectors are designed to work well with FCIQMC and KrylovKit.\n\nThey lie somewhere between AbstractDicts and sparse AbstractVectors, generally behaving like a dictionary, while supportting various linear algebra functionality. Indexing with a value not stored in the dictionary returns zero(V). Setting a stored value to 0 or below eps(V::AbstractFloat) removes the value from the dictionary. Their length signals the number of stored elements, not the size of the vector space.\n\nThey have a StochasticStyle which selects the spawning algorithm in FCIQMC.\n\nTo iterate over an AbstractDVec, use pairs or values.\n\nInterface\n\nThe interface is similar to the AbstractDict interface.\n\nImplement what would be needed for the AbstractDict interface (pairs, keys, values, setindex!, getindex, delete!, length, haskey, empty!, isempty) and, in addition:\n\nStochasticStyle\nstorage(dv) returns an AbstractDict storing the raw data with possibly different valtype than V.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.AbstractProjector","page":"API","title":"Rimu.DictVectors.AbstractProjector","text":"Abstract supertype for projectors to be used in in lieu of DVecs or Vectors.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.CoherentInitiator","page":"API","title":"Rimu.DictVectors.CoherentInitiator","text":"CoherentInitiator(threshold) <: InitiatorRule\n\nInitiator rule to be passed to InitiatorDVec. An initiator is a configuration add with a coefficient with magnitude abs(v[add]) > threshold. Rules:\n\nInitiators can spawn anywhere.\nNon-initiators can spawn to initiators.\nMultiple non-initiators can spawn to a single non-initiator if their contributions add up to a value greater than the initiator threshold.\nSee InitiatorRule.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.DVec","page":"API","title":"Rimu.DictVectors.DVec","text":"DVec{K,V,D<:AbstractDict{K,V},S}\n\nDictionary-based vector-like data structure for use with FCIQMC and KrylovKit. While mostly behaving like a Dict, it supports various linear algebra operations such as norm and dot. It has a StochasticStyle that is used to select an appropriate spawning strategy in the FCIQMC algorithm.\n\nSee also: AbstractDVec.\n\nConstructors\n\nDVec(dict::AbstractDict[; style, capacity]): create a DVec with dict for storage. Note that the data may or may not be copied.\nDVec(args...[; style, capacity]): args... are passed to the Dict constructor. The Dict is used for storage.\nDVec{K,V}([; style, capacity]): create an empty DVec{K,V}.\nDVec(dv::AbstractDVec[; style, capacity]): create a DVec with the same contents as  adv. The style is inherited from dv by default.\n\nThe default style is selected based on the DVec's valtype (see default_style). If a style is given and the valtype does not match the style's eltype, the values are converted to an appropriate type.\n\nThe capacity argument is optional and sets the initial size of the DVec via sizehint!.\n\nExamples\n\njulia> dv = DVec(:a => 1)\nDVec{Symbol,Int64} with 1 entries, style = IsStochasticInteger{Int64}()\n  :a => 1\n\njulia> dv = DVec(:a => 2, :b => 3; style=IsDynamicSemistochastic())\nDVec{Symbol,Float32} with 2 entries, style = IsDynamicSemistochastic{Float64, true}(1.0, Inf, 1.0)\n  :a => 2.0\n  :b => 3.0\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.Initiator","page":"API","title":"Rimu.DictVectors.Initiator","text":"Initiator(threshold) <: InitiatorRule\n\nInitiator rule to be passed to InitiatorDVec. An initiator is a configuration add with a coefficient with magnitude abs(v[add]) > threshold. Rules:\n\nInitiators can spawn anywhere.\nNon-initiators can spawn to initiators.\n\nSee InitiatorRule.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.InitiatorDVec","page":"API","title":"Rimu.DictVectors.InitiatorDVec","text":"InitiatorDVec{K,V} <: AbstractDVec{K,V}\n\nDictionary-based vector-like data structure for use with lomc! and KrylovKit.jl. See AbstractDVec. Functionally identical to DVec, but contains InitiatorValues internally in order to facilitate initiator methods. How the initiators are handled is controlled by the initiator keyword argument (see below).\n\nConstructors\n\nInitiatorDVec(dict::AbstractDict[; style, initiator, capacity]): create an InitiatorDVec with dict for storage.  Note that the data may or may not be copied.\nInitiatorDVec(args...[; style, initiator, capacity]): args... are passed to the Dict constructor. The Dict is used for storage.\nInitiatorDVec{K,V}([; style, initiator, capacity]): create an empty InitiatorDVec{K,V}.\nInitiatorDVec(dv::AbstractDVec[; style, initiator, capacity]): create an InitiatorDVec  with the same contents as dv. The style is inherited from dv by default.\n\nKeyword  arguments\n\nstyle: A valid StochasticStyle.  The default is selected based on the InitiatorDVec's valtype (see default_style). If a style is given and the valtype does not match the style's eltype, the values are converted to an appropriate type.\ninitiator = Initiator(1): A valid InitiatorRule. See Initiator.\ncapacity: Indicative size as Int. Optional. Sets the initial size of the InitiatorDVec via sizehint!.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.InitiatorIterator","page":"API","title":"Rimu.DictVectors.InitiatorIterator","text":"InitiatorIterator\n\nIterator over pairs or values of an InitiatorDVec. Supports the SplittablesBase interface.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.InitiatorRule","page":"API","title":"Rimu.DictVectors.InitiatorRule","text":"InitiatorRule{V}\n\nAbstract type for defining initiator rules for InitiatorDVec. Concrete implementations:\n\nInitiator\nSimpleInitiator\nCoherentInitiator\n\nWhen defining a new InitiatorRule, also define a corresponding method for value!\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.InitiatorValue","page":"API","title":"Rimu.DictVectors.InitiatorValue","text":"InitiatorValue{V}(; safe::V, unsafe::V, initiator::V) where V\n\nComposite \"walker\" with three fields. For use with InitiatorDVecs.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsDeterministic","page":"API","title":"Rimu.DictVectors.IsDeterministic","text":"IsDeterministic{T=Float64}() <: StochasticStyle{T}\n\nTrait for generalised vector of configuration indicating deterministic propagation of walkers.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsDynamicSemistochastic","page":"API","title":"Rimu.DictVectors.IsDynamicSemistochastic","text":"IsDynamicSemistochastic{T=Float64}(rel_threshold=1, abs_threshold=Inf, proj_threshold=1) <: StochasticStyle{T}\n\nQMC propagation with non-integer walker numbers and reduced noise. All possible spawns are performed deterministically when number of walkers in a configuration is high. Stochastic vector compression with threshold proj_threshold is applied after spawning and diagonal death steps.\n\nUnlike with IsStochasticWithThreshold, when late_projection is set to true, walker annihilation is done before the stochastic vector compression.\n\nParameters:\n\nlate_projection = true: If set to true, threshold projection is done after all spawns are collected, otherwise, values are projected as they are being spawned.\nrel_threshold = 1.0: If the walker number on a configuration times this threshold is greater than the number of offdiagonals, spawning is done deterministically. Should be set to 1 or more for best performance.\nabs_threshold = Inf: If the walker number on a configuration is greater than this value, spawning is done deterministically. Can be set to e.g abs_threshold = 0.1 * target_walkers.\nproj_threshold = 1.0: Values below this number are stochastically projected to this value or zero. See also IsStochasticWithThreshold.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsStochastic2Pop","page":"API","title":"Rimu.DictVectors.IsStochastic2Pop","text":"IsStochastic2Pop{T=Complex{Int}}() <: StochasticStyle{T}\n\nTrait for generalised vector of configurations indicating stochastic propagation with complex walker numbers representing two populations of integer walkers.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsStochasticInteger","page":"API","title":"Rimu.DictVectors.IsStochasticInteger","text":"IsStochasticInteger{T=Int}() <: StochasticStyle{T}\n\nTrait for generalised vector of configurations indicating stochastic propagation as seen in the original FCIQMC algorithm.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsStochasticWithThreshold","page":"API","title":"Rimu.DictVectors.IsStochasticWithThreshold","text":"IsStochasticWithThreshold(threshold=1.0) <: StochasticStyle\n\nTrait for generalised vector of configurations indicating stochastic propagation with real walker numbers and cutoff threshold.\n\nDuring stochastic propagation, walker numbers small than threshold will be stochastically projected to either zero or threshold.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.Norm1ProjectorPPop","page":"API","title":"Rimu.DictVectors.Norm1ProjectorPPop","text":"Norm1ProjectorPPop()\n\nResults in computing the one-norm per population when used in dot(). E.g.\n\ndot(Norm1ProjectorPPop(),x)\n-> norm(real.(x),1) + im*norm(imag.(x),1)\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.Norm2Projector","page":"API","title":"Rimu.DictVectors.Norm2Projector","text":"Norm2Projector()\n\nResults in computing the two-norm when used in dot(). E.g.\n\ndot(NormProjector(),x)\n-> norm(x,2) # with type Float64\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.NormProjector","page":"API","title":"Rimu.DictVectors.NormProjector","text":"NormProjector()\n\nResults in computing the one-norm when used in dot(). E.g.\n\ndot(NormProjector(),x)\n-> norm(x,1)\n\nNormProjector() thus represents the vector sign.(x).\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.PopsProjector","page":"API","title":"Rimu.DictVectors.PopsProjector","text":"PopsProjector()\n\nResults in computing the projection of one population on the other when used in dot(). E.g.\n\ndot(PopsProjector(),x)\n-> real(x) ⋅ imag(x)\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.SimpleInitiator","page":"API","title":"Rimu.DictVectors.SimpleInitiator","text":"SimpleInitiator(threshold) <: InitiatorRule\n\nSimplified initiator rule to be passed to InitiatorDVec. An initiator is a configuration add with a coefficient with magnitude abs(v[add]) > threshold. Rules:\n\nInitiators can spawn anywhere.\nNon-initiators cannot spawn.\n\nSee InitiatorRule.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.StochasticStyle","page":"API","title":"Rimu.DictVectors.StochasticStyle","text":"StochasticStyle(v)\n\nStochasticStyle specifies the native style of the generalised vector v that determines how simulations are to proceed. This can be fully stochastic (with IsStochasticInteger), fully deterministic (with IsDeterministic), or stochastic with floating point walker numbers and threshold (with IsStochasticWithThreshold).\n\nWhen defining a new StochasticStyle, subtype it as MyStyle<:StochasticStyle{T} where T is the concrete value type the style is designed to work with.\n\nFor it to work with FCIQMC, a StochasticStyle must define the following:\n\nfciqmc_col!(::StochasticStyle, w, H, address, value, shift, dτ)\nstep_stats(::StochasticStyle)\n\nOptionally, it can also define update_dvec!, which can be used to perform arbitrary transformations on the dvec after the spawning step is complete.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.StyleUnknown","page":"API","title":"Rimu.DictVectors.StyleUnknown","text":"StyleUnknown{T}() <: StochasticStyle\n\nTrait for value types not (currently) compatible with FCIQMC. This style makes it possible to construct dict vectors with unsupported valtypes.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.UniformProjector","page":"API","title":"Rimu.DictVectors.UniformProjector","text":"UniformProjector()\n\nRepresents a vector with all elements 1. To be used with dot(). Minimizes memory allocations.\n\nUniformProjector()⋅v == sum(v)\ndot(UniformProjector(), LO, v) == sum(LO*v)\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.add!-Union{Tuple{K}, Tuple{AbstractDVec{K, V} where V, AbstractDVec{K, V} where V}} where K","page":"API","title":"Rimu.DictVectors.add!","text":"add!(x::AbstractDVec,y::AbstactDVec)\n\nInplace add x+y and store result in x.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T<:Integer","page":"API","title":"Rimu.DictVectors.default_style","text":"default_style(::Type)\n\nPick a StochasticStyle based on the value type. Throws an error if no known default style is known.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.deposit!-NTuple{4, Any}","page":"API","title":"Rimu.DictVectors.deposit!","text":"deposit!(w::AbstractDVec, add, val, parent::Pair)\n\nAdd val into w at address add, taking into account initiator rules if applicable. parent contains the address => value pair from which the pair add => val was created. InitiatorDVec can intercept this and add its own functionality.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.deposit!-Union{Tuple{V}, Tuple{InitiatorDVec{var\"#s6\", V, D, S, I} where {var\"#s6\", D<:AbstractDict{var\"#s6\", Rimu.DictVectors.InitiatorValue{V}}, S<:StochasticStyle{V}, I<:Rimu.DictVectors.InitiatorRule}, Any, Any, Any}} where V","page":"API","title":"Rimu.DictVectors.deposit!","text":"deposit!(w::InitiatorDVec, add, val, p_add=>p_val)\n\nAdd val into w at address add as an InitiatorValue.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.localpart-Tuple{Any}","page":"API","title":"Rimu.DictVectors.localpart","text":"localpart(dv) -> AbstractDVec\n\nGet the part of dv that is located on this MPI rank. Returns dv itself for DictVectors.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.storage","page":"API","title":"Rimu.DictVectors.storage","text":"storage(dvec) -> AbstractDict\n\nReturn the raw storage associated with dvec as an AbstractDict. Used in MPI communication.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Rimu.DictVectors.value","page":"API","title":"Rimu.DictVectors.value","text":"value(i::InitiatorRule, v::InitiatorValue)\n\nConvert the InitiatorValue v into a scalar value according to the InitiatorRule i.\n\nInternal function that implements functionality of InitiatorDVec.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Rimu.DictVectors.walkernumber-Tuple{Any}","page":"API","title":"Rimu.DictVectors.walkernumber","text":"walkernumber(w)\n\nCompute the number of walkers in w. It is used for updating the shift. Overload this function for modifying population control.\n\nIn most cases walkernumber(w) is identical to norm(w,1). For AbstractDVecs with complex coefficients it reports the one norm separately for the real and the imaginary part as a ComplexF64. See Norm1ProjectorPPop.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.zero!-Tuple{AbstractDVec}","page":"API","title":"Rimu.DictVectors.zero!","text":"zero!(v)\n\nReplace v by a zero vector as an inplace operation. For AbstractDVec types it means removing all non-zero elements. For AbstractArrays, it sets all of the values to zero.\n\n\n\n\n\n","category":"method"},{"location":"API.html#StatsTools","page":"API","title":"StatsTools","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [StatsTools]","category":"page"},{"location":"API.html#Blocking","page":"API","title":"Blocking","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [Blocking]","category":"page"},{"location":"API.html#ConsistentRNG","page":"API","title":"ConsistentRNG","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Link to Module ConsistentRNG.jl","category":"page"},{"location":"API.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"","category":"page"}]
}
